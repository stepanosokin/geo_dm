# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeoDM
                                 A QGIS plugin
 This plugin provides geophysical data management tasks inside metadata database by stepanosokin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-05-30
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Stepan Osokin
        email                : stepanosokin@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
# from PyQt5.QtWebEngineWidgets import QWebEngineView
from qgis.PyQt.QtCore import Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QTableWidgetItem, QTableWidget, QPushButton, QAbstractItemView
from qgis.core import \
    Qgis, \
    QgsProject, \
    QgsLayerTreeUtils, \
    QgsVectorLayerSelectedFeatureSource, \
    QgsCoordinateReferenceSystem, \
    QgsMapLayer, \
    QgsMapLayerType, \
    QgsCoordinateTransform
import psycopg2
from psycopg2.extras import *
from datetime import datetime


# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .geo_dm_dialogs import *
import os.path


class GeoDM:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GeoDM_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Geophysical Data Management')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        cwd = os.getcwd()
        with open('C:/Users/saosokin/AppData/Roaming/QGIS/QGIS3/profiles/default/python/plugins/geo_dm/.pgdsn', encoding='utf-8') as dsnf:
            self.dsn = dsnf.read().replace('\n', '')
        # self.pgconn = psycopg2.connect(dsn)

        self.proc_list = []

        self.null_value = 'NULL'

        self.processings = 'dm.processings'
        self.processings_view = 'dm.processings_view'
        self.processing_types = 'dm.processing_types'
        self.projects = 'dm.projects'
        self.companies = 'dm.companies'
        self.contracts = 'dm.contracts'
        self.contracts_view = 'dm.contracts_view'
        self.reports = 'dm.reports'
        self.reports_view = 'dm.reports_view'
        self.projects = 'dm.projects'
        self.companies = 'dm.companies'
        self.contract_types = 'dm.contract_types'
        self.report_types = 'dm.report_types'
        self.conf = 'dm.conf'
        self.seismic_lines_processed_2d = 'dm.seismic_lines_processed_2d'
        self.seismic_pols_processed_3d = 'dm.seismic_pols_processed_3d'
        self.surveys_view = 'dm.surveys_view'
        self.surveys = 'dm.surveys'
        self.survey_id_seq = 'dm.surveys_survey_id_seq'
        self.proc_geom_to_surveys = 'dm.proc_geom_to_surveys'
        self.survey_types = 'dm.survey_types'
        self.location_types = 'dm.location_types'
        self.reports_to_surveys = 'dm.reports_to_surveys'
        self.seismic_lines_field_2d = 'dm.seismic_lines_field_2d'
        self.seismic_pols_field_3d = 'dm.seismic_pols_field_3d'
        self.seismic_datasets_view = 'dm.seismic_datasets_view'
        self.seismic_datasets = 'dm.seismic_datasets'
        self.seismic_datasets_dataset_id_seq = 'dm.seismic_datasets_dataset_id_seq'
        self.datasets_to_geometries = 'dm.datasets_to_geometries'
        self.seismic_datasets_to_transmittals = 'dm.seismic_datasets_to_transmittals'
        self.datasource_types = 'dm.datasource_types'
        self.seismic_types = 'dm.seismic_types'
        self.formats = 'dm.formats'
        self.data_quality = 'dm.data_quality'
        self.drives = 'dm.drives'
        self.drives_view = 'dm.drives_view'
        self.drives_to_datasets = 'dm.drives_to_datasets'
        self.links = 'dm.links'
        self.links_to_datasets = 'dm.links_to_datasets'
        self.transmittals = 'dm.transmittals'
        self.transmittals_view = 'dm.transmittals_view'
        self.drive_types = 'dm.drive_types'
        self.transmittal_types = 'dm.transmittal_types'

        self.datasets_to_geometries_list = None
        self.seismic_datasets_view_list = None

        self.survey_id_filter = None
        self.proc_id_filter = None
        self.dataset_id_filter = None

        self.selectedProcLayer = None
        self.selectedFieldLayer = None

        self.selectedProcFeaturesList = []
        self.selectedFieldFeaturesList = []

        self.sql = ''

        self.show_datasets_for_selected_proc = True
        self.show_datasets_for_selected_surveys = True

        self.mode = None
        self.wind = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GeoDM', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/geo_dm/icon.png'
        self.add_action(
            ':/plugins/geo_dm/procseis.png',
            text=self.tr(u'Manage Processed Seismic'),
            callback=self.run_mps,
            parent=self.iface.mainWindow())

        self.add_action(
            ':/plugins/geo_dm/fieldseis.png',
            text=self.tr(u'Manage Field Seismic'),
            callback=self.run_mfs,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Geophysical Data Management'),
                action)
            self.iface.removeToolBarIcon(action)


    def get_surveys_from_postgres(self):
        sql = f"select * from {self.surveys_view}"

        # filter_str = self.dockwind.surveyFilterLineEdit.text().lower().strip()
        filter_str = self.wind.surveyFilterLineEdit.text().lower().strip()
        if filter_str not in ['', None]:
            sql += f" where (LOWER(name) like '%{filter_str}%' or LOWER(survey_type) like '%{filter_str}%' or year::text = '{filter_str}' " \
                   f"or LOWER(acquisition_company) like '%{filter_str}%' or LOWER(acquisition_company_shortname) like '%{filter_str}%' " \
                   f"or LOWER(acquisition_contract_number) like '%{filter_str}%' or LOWER(acquisition_contract_name) like '%{filter_str}%' " \
                   f"or LOWER(location_type) like '%{filter_str}%')"
        if self.survey_id_filter:
            if filter_str not in ['', None]:
                sql += ' and'
            else:
                sql += ' where'
            sql += f" survey_id in ({', '.join([str(x) for x in self.survey_id_filter])})"
        sql += ' order by name'
        try:
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                if pgconn:
                    with pgconn.cursor() as cur:
                        cur.execute(sql)
                        self.surveys_view_list = list(cur.fetchall())
                        sql = f"select processed_geom_id, survey_id from {self.proc_geom_to_surveys}"
                        cur.execute(sql)
                        self.proc_geom_to_surveys_list = list(cur.fetchall())
                        return True
                else:
                    self.iface.messageBar().pushMessage('Ошибка', 'Не удалось загрузить данные о съемках из базы',
                                                    level=Qgis.Critical, duration=5)
                    return False
        except:
            self.iface.messageBar().pushMessage('Ошибка', 'Не удалось загрузить данные о съемках из базы ' + sql,
                                                level=Qgis.Critical, duration=5)
            return False


    def refresh_surveys(self):
        # self.dockwind.surveyTableWidget.clear()
        # self.dockwind.surveyTableWidget.setRowCount(0)
        # self.dockwind.surveyTableWidget.setColumnCount(4)
        # self.dockwind.surveyTableWidget.setHorizontalHeaderLabels(['Название', 'Тип', 'Исполнитель', 'Год'])
        # header = self.dockwind.surveyTableWidget.horizontalHeader()
        self.wind.surveyTableWidget.clear()
        self.wind.surveyTableWidget.setRowCount(0)
        self.wind.surveyTableWidget.setColumnCount(4)
        self.wind.surveyTableWidget.setHorizontalHeaderLabels(['Название', 'Тип', 'Исполнитель', 'Год'])
        header = self.wind.surveyTableWidget.horizontalHeader()

        header.resizeSection(0, 100)
        header.resizeSection(1, 5)
        header.resizeSection(2, 100)
        header.resizeSection(3, 20)
        # if index_list == None:
        #     index_list = []
        if self.get_surveys_from_postgres():
            for i, survey_row in enumerate(self.surveys_view_list):
                # self.dockwind.surveyTableWidget.insertRow(i)
                # citem = QTableWidgetItem(survey_row['name'])
                # citem.setToolTip(str(survey_row['name']))
                # citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                # self.dockwind.surveyTableWidget.setItem(i, 0, citem)
                # citem = QTableWidgetItem(survey_row['survey_type'])
                # citem.setToolTip(str(survey_row['survey_type']))
                # citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                # self.dockwind.surveyTableWidget.setItem(i, 1, citem)
                # citem = QTableWidgetItem(survey_row['acquisition_company_shortname'])
                # citem.setToolTip(str(survey_row['acquisition_company']))
                # citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                # self.dockwind.surveyTableWidget.setItem(i, 2, citem)
                # citem = QTableWidgetItem(str(survey_row['year']))
                # citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                # self.dockwind.surveyTableWidget.setItem(i, 3, citem)

                self.wind.surveyTableWidget.insertRow(i)
                citem = QTableWidgetItem(survey_row['name'])
                citem.setToolTip(str(survey_row['name']))
                citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.wind.surveyTableWidget.setItem(i, 0, citem)
                citem = QTableWidgetItem(survey_row['survey_type'])
                citem.setToolTip(str(survey_row['survey_type']))
                citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.wind.surveyTableWidget.setItem(i, 1, citem)
                citem = QTableWidgetItem(survey_row['acquisition_company_shortname'])
                citem.setToolTip(str(survey_row['acquisition_company']))
                citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.wind.surveyTableWidget.setItem(i, 2, citem)
                citem = QTableWidgetItem(str(survey_row['year']))
                citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.wind.surveyTableWidget.setItem(i, 3, citem)


    def select_surveys_by_geometry(self):
        if all([self.mode == 'proc', self.selectedProcLayer, self.selectedProcFeaturesList]):
            # if self.selectedProcLayer != None and len(self.selectedProcFeaturesList) > 0:
            if 'proc_id' in [f.name() for f in self.selectedProcLayer.fields()]:
                if 'pol_id' in [f.name() for f in self.selectedProcLayer.fields()]:
                    selected_features_ids_list = list(set([f.attribute('pol_id') for f in self.selectedProcFeaturesList]))
                elif 'line_id' in [f.name() for f in self.selectedProcLayer.fields()]:
                    selected_features_ids_list = list(set([f.attribute('line_id') for f in self.selectedProcFeaturesList]))
                else:
                    selected_features_ids_list = []
                selected_features_survey_ids = [y[1] for y in self.proc_geom_to_surveys_list if y[0] in selected_features_ids_list]
            # else:
            #     selected_features_survey_ids = []
            else:
                selected_features_survey_ids = []
        elif all([self.mode == 'field', self.selectedFieldLayer, self.selectedFieldFeaturesList]):
            if 'survey_id' in [f.name() for f in self.selectedFieldLayer.fields()]:
                selected_features_survey_ids = list(set([f.attribute('survey_id') for f in self.selectedFieldFeaturesList]))
            else:
                selected_features_survey_ids = []
        else:
            self.iface.messageBar().pushMessage('Ошибка', f"Нужно выбрать слой и объекты в нем",
                                            level=Qgis.Warning,
                                            duration=5)
            selected_features_survey_ids = []

        # if selected_features_survey_ids:
        [x.setSelected(False) for x in self.wind.surveyTableWidget.selectedItems()]
        self.wind.surveyTableWidget.clear()
        self.wind.surveyTableWidget.setHorizontalHeaderLabels(['Название', 'Тип', 'Исполнитель', 'Год'])
        self.wind.surveyTableWidget.setRowCount(0)

        if selected_features_survey_ids:
            self.survey_id_filter = selected_features_survey_ids
        else:
            self.survey_id_filter = [-1]
        self.refresh_surveys()
        self.survey_id_filter = None
        # self.refresh_surveys(selected_survey_indexes)
        # else:
        #     self.iface.messageBar().pushMessage('Ошибка', f"Нужно выбрать слой и объекты в нем",
        #                                     level=Qgis.Warning,
        #                                     duration=5)


    def select_geometry_by_surveys(self):
        # selected_survey_rows = list(set([x.row() for x in self.dockwind.surveyTableWidget.selectedItems()]))
        if self.mode in ('proc', 'field'):
            selected_survey_rows = list(set([x.row() for x in self.wind.surveyTableWidget.selectedItems()]))
        else:
            selected_survey_rows = None
        if self.mode == 'proc':
            geom_lyr = self.selectedProcLayer
        elif self.mode == 'field':
            geom_lyr = self.selectedFieldLayer
        else:
            geom_lyr = None
        # self.iface.messageBar().pushMessage('selected_survey_rows', ', '.join([str(x) for x in selected_survey_rows]), level=Qgis.Success, duration=5)
        if selected_survey_rows and geom_lyr:
            selected_survey_ids = [self.surveys_view_list[i]['survey_id'] for i in selected_survey_rows]
            # self.iface.messageBar().pushMessage('selected_survey_ids', ', '.join([str(x) for x in selected_survey_ids]), level=Qgis.Success, duration=5)

            if self.mode == 'proc' and selected_survey_ids and geom_lyr and \
                    any(['line_id' in [f.name() for f in geom_lyr.fields()],
                         'pol_id' in [f.name() for f in geom_lyr.fields()]]):
                geom_string = ', '.join([str(x['processed_geom_id']) for x in self.proc_geom_to_surveys_list if x['survey_id'] in selected_survey_ids])

                if 'line_id' in [f.name() for f in self.selectedProcLayer.fields()]:
                    gfield = 'line_id'
                else:
                    gfield = 'pol_id'
                query = f'"{gfield}" in ({geom_string})'
            elif all([self.mode == 'field', selected_survey_ids, geom_lyr, 'survey_id' in [f.name() for f in geom_lyr.fields()]]):
                geom_string = ', '.join([str(x['survey_id']) for x in self.surveys_view_list if x['survey_id'] in selected_survey_ids])
                query = f'"survey_id" in ({geom_string})'
            else:
                query = None
            geom_lyr.removeSelection()
            # self.iface.messageBar().pushMessage('query', query, level=Qgis.Success, duration=5)
            if query:
                geom_lyr.selectByExpression(query)
                if geom_lyr.selectedFeatures():
                    project_crs = QgsCoordinateReferenceSystem(QgsProject.instance().crs())
                    layer_crs = geom_lyr.crs()
                    lyr2proj = QgsCoordinateTransform(layer_crs, project_crs, QgsProject.instance())
                    box = lyr2proj.transformBoundingBox(geom_lyr.boundingBoxOfSelected())
                    self.iface.mapCanvas().setExtent(box)
                    self.iface.mapCanvas().refresh()
            else:
                self.iface.messageBar().pushMessage('Ошибка', f"Нужно выбрать съемку(и) и слой с геометрией", level=Qgis.Warning, duration=5)


    def link_selected_surveys_to_geometry(self):
        # selected_cells = self.dockwind.surveyTableWidget.selectedItems()
        if self.mode in ('proc', 'field'):
            selected_cells = self.wind.surveyTableWidget.selectedItems()
            selected_rows = list(set([x.row() for x in selected_cells]))
        else:
            selected_cells = None
            selected_rows = None
        if not selected_rows:
            self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать одну или несколько съемок', level=Qgis.Warning, duration=3)
        else:
            survey_ids = [self.surveys_view_list[i]['survey_id'] for i in selected_rows]
            sql = None
            geom_ids = None
            if all([self.mode == 'proc', self.selectedProcLayer, self.selectedProcFeaturesList]):
                if any(['line_id' in [f.name() for f in self.selectedProcLayer.fields()],
                        'pol_id' in [f.name() for f in self.selectedProcLayer.fields()]]):
                    # if self.selectedProcLayer != None and len(self.selectedProcFeaturesList) > 0 and \
                    #         any(['line_id' in [f.name() for f in self.selectedProcLayer.fields()],
                    #              'pol_id' in [f.name() for f in self.selectedProcLayer.fields()]]):
                    if 'line_id' in [f.name() for f in self.selectedProcLayer.fields()]:
                        gfield = 'line_id'
                        table = self.seismic_lines_processed_2d
                    else:
                        gfield = 'pol_id'
                        table = self.seismic_pols_processed_3d
                    geom_ids = [x[gfield] for x in self.selectedProcFeaturesList]
                    sql = f"insert into {self.proc_geom_to_surveys}(processed_geom_id, survey_id) values"
                    # sql += ', '.join['(' + str(g) + ', ' + str(s) + ')' for g, s in geom_ids, survey_ids]
                    values_to_insert = []
                    for geom_id in geom_ids:
                        for survey_id in survey_ids:
                            values_to_insert.append(f"({str(geom_id)}, {str(survey_id)})")
                    sql += ', '.join(values_to_insert)
                    self.sql = sql
                    # self.iface.messageBar().pushMessage('sql', sql, level=Qgis.Success, duration=5)
            elif all([len(survey_ids) == 1, self.mode == 'field', self.selectedFieldLayer, self.selectedFieldFeaturesList]):
                if any(['field_line_id' in [f.name() for f in self.selectedFieldLayer.fields()],
                         'pol_id' in [f.name() for f in self.selectedFieldLayer.fields()]]):
                    if 'field_line_id' in [f.name() for f in self.selectedFieldLayer.fields()]:
                        gfield = 'field_line_id'
                        table = self.seismic_lines_field_2d
                    else:
                        gfield = 'pol_id'
                        table = self.seismic_pols_field_3d
                    geom_ids = [x[gfield] for x in self.selectedFieldFeaturesList]
                    sql = f"update {table} set survey_id = {str(survey_ids[0])} where {gfield} in ({', '.join([str(x) for x in geom_ids])});"
                    # self.iface.messageBar().pushMessage('sql', sql, level=Qgis.Success, duration=3)
                    self.sql = sql
            elif all([len(survey_ids) > 1, self.mode == 'field']):
                self.iface.messageBar().pushMessage('Ошибка', 'Для присвоения съемки полевой геометрии ужно выбрать одну съемку и хотя бы одну геометрию',
                                                    level=Qgis.Warning, duration=3)
            else:
                if self.mode == 'proc':
                    self.iface.messageBar().pushMessage('Ошибка',
                                                        'Для присвоения съемки обработанной геометрии ужно выбрать хотя бы одну съемку и хотя бы одну геометрию',
                                                        level=Qgis.Warning, duration=3)
                elif self.mode == 'field':
                    self.iface.messageBar().pushMessage('Ошибка',
                                                    'Для присвоения съемки полевой геометрии ужно выбрать одну съемку и хотя бы одну геометрию',
                                                    level=Qgis.Warning, duration=3)
                else:
                    self.iface.messageBar().pushMessage('Ошибка',
                                                        'Для связывания съемки и геометрии ужно выбрать хотя бы одну съемку и хотя бы одну геометрию',
                                                        level=Qgis.Warning, duration=3)
            if sql:
                mwidget = self.iface.messageBar().createMessage(f"Связать {str(len(survey_ids))} съемок с {str(len(geom_ids))} объектами в активном слое?")
                mbutton = QPushButton(mwidget)
                mbutton.setText('Подтвердить')
                mbutton.pressed.connect(self.execute_sql)
                mwidget.layout().addWidget(mbutton)
                self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=5)


    def unlink_selected_surveys_from_geometry(self):
        if self.mode in ('proc', 'field'):
            selected_cells = self.wind.surveyTableWidget.selectedItems()
            selected_rows = list(set([x.row() for x in selected_cells]))
        else:
            selected_cells = None
            selected_rows = None
        if not selected_rows:
            self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать одну или несколько съемок', level=Qgis.Warning, duration=3)
        else:
            survey_ids = [self.surveys_view_list[i]['survey_id'] for i in selected_rows]
            sql = None

            if all([self.mode == 'proc', self.selectedProcLayer, self.selectedProcFeaturesList]):
                if any(['line_id' in [f.name() for f in self.selectedProcLayer.fields()],
                         'pol_id' in [f.name() for f in self.selectedProcLayer.fields()]]):
                    if 'line_id' in [f.name() for f in self.selectedProcLayer.fields()]:
                        gfield = 'line_id'
                        table = self.seismic_lines_processed_2d
                    else:
                        gfield = 'pol_id'
                        table = self.seismic_pols_processed_3d
                    geom_ids = [x[gfield] for x in self.selectedProcFeaturesList]
                    sql = f"delete from {self.proc_geom_to_surveys} where "
                    # sql += ', '.join['(' + str(g) + ', ' + str(s) + ')' for g, s in geom_ids, survey_ids]
                    values_to_delete = []
                    for geom_id in geom_ids:
                        for survey_id in survey_ids:
                            values_to_delete.append(f"(processed_geom_id = {str(geom_id)} and survey_id = {str(survey_id)})")
                    sql += ' or '.join(values_to_delete)
                    self.sql = sql
                    # self.iface.messageBar().pushMessage('sql', sql, level=Qgis.Success, duration=5)
                    mwidget = self.iface.messageBar().createMessage(f"Удалить связь {str(len(survey_ids))} съемок и {str(len(geom_ids))} объектов в активном слое?")
                    mbutton = QPushButton(mwidget)
                    mbutton.setText('Подтвердить')
                    mbutton.pressed.connect(self.execute_sql)
                    mwidget.layout().addWidget(mbutton)
                    self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=5)
            elif all([self.mode == 'field', self.selectedFieldLayer, self.selectedFieldFeaturesList]):
                if any(['field_line_id' in [f.name() for f in self.selectedFieldLayer.fields()],
                        'pol_id' in [f.name() for f in self.selectedFieldLayer.fields()]]):
                    if 'field_line_id' in [f.name() for f in self.selectedFieldLayer.fields()]:
                        gfield = 'field_line_id'
                        table = self.seismic_lines_field_2d
                    else:
                        gfield = 'pol_id'
                        table = self.seismic_pols_field_3d
                    geom_ids = [x[gfield] for x in self.selectedFieldFeaturesList]
                    sql = f"update {table} set survey_id = NULL where {gfield} in ({', '.join([str(x) for x in geom_ids])}) and survey_id in ({', '.join([str(y) for y in survey_ids])});"
                    self.sql = sql
                    mwidget = self.iface.messageBar().createMessage(
                        f"Удалить связь {str(len(survey_ids))} съемок и {str(len(geom_ids))} объектов в активном слое?")
                    mbutton = QPushButton(mwidget)
                    mbutton.setText('Подтвердить')
                    mbutton.pressed.connect(self.execute_sql)
                    mwidget.layout().addWidget(mbutton)
                    self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=5)
            else:
                self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать хотя бы одну геометрию',
                                                    level=Qgis.Warning,
                                                    duration=3)


    def get_proc_from_postgres(self):
        try:
            sql = f"select * from {self.processings_view}"
            filter_str = self.dockwind.procFilterLineEdit.text().lower().strip()
            if filter_str:
                sql += f" where (LOWER(name) like '%{filter_str}%' or LOWER(proc_type) like '%{filter_str}%' or year::text = '{filter_str}' " \
                       f"or LOWER(company_name) like '%{filter_str}%' or LOWER(company_shortname) like '%{filter_str}%' " \
                       f"or LOWER(contract_number) like '%{filter_str}%' or LOWER(contract_name) like '%{filter_str}%' " \
                       f"or LOWER(report_name) like '%{filter_str}%' or LOWER(project_name) like '%{filter_str}%')"
            if self.proc_id_filter:
                if filter_str:
                    sql += ' and'
                else:
                    sql += ' where'
                sql += f" proc_id in ({', '.join([str(x) for x in self.proc_id_filter])})"
            sql += ' order by name'
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                if pgconn:
                    # with self.pgconn.cursor() as cur:
                    with pgconn.cursor() as cur:
                        # cur = pgconn.cursor()
                        # cur.execute(f"select * from {self.processings_view} order by name")
                        cur.execute(sql)
                        # processings = cur.fetchall()
                        self.proc_list = list(cur.fetchall())
                        # cur.close()
                        # dsnf.close()
                        return True
                else:
                    self.iface.messageBar().pushMessage('Ошибка', 'Не удалось загрузить данные об обработках из базы',
                                                        level=Qgis.Critical, duration=5)
                    return False
        except:
            self.iface.messageBar().pushMessage('Ошибка', 'Не удалось загрузить данные об обработках из базы',
                                                level=Qgis.Critical, duration=5)
            return False
        pass


    def refresh_processings(self):
        self.dockwind.procTableWidget.clear()
        self.dockwind.procTableWidget.setRowCount(0)
        self.dockwind.procTableWidget.setColumnCount(3)
        self.dockwind.procTableWidget.setHorizontalHeaderLabels(['Название', 'Автор', 'Год'])
        header = self.dockwind.procTableWidget.horizontalHeader()
        header.resizeSection(0, 200)
        header.resizeSection(1, 100)
        header.resizeSection(2, 20)
        # processings = self.get_proc_from_postgres()
        if self.get_proc_from_postgres():
        # if processings[0]:
        #     for i, proc_row in enumerate(processings[1]):
        #     self.iface.messageBar().pushMessage('Список обработок', ' '.join([str(x) for x in self.proc_list[0]]), level=Qgis.Success, duration=5)
            for i, proc_row in enumerate(self.proc_list):
                self.dockwind.procTableWidget.insertRow(i)
                citem = QTableWidgetItem(proc_row['name'])
                citem.setToolTip(str(proc_row['name']))
                citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)

                self.dockwind.procTableWidget.setItem(i, 0, citem)
                citem = QTableWidgetItem(proc_row['company_shortname'])
                citem.setToolTip(str(proc_row['company_name']))
                citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.dockwind.procTableWidget.setItem(i, 1, citem)
                citem = QTableWidgetItem(str(proc_row['year']))
                # citem.setToolTip(str(proc_row[6]))
                citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.dockwind.procTableWidget.setItem(i, 2, citem)


    def execute_sql(self):
        try:

            # with open('.pgdsn', encoding='utf-8') as dsnf:
            #     dsn = dsnf.read().replace('\n', '')
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:

                # with self.pgconn.cursor() as cur:
                with pgconn.cursor() as cur:
                    cur.execute(self.sql)
                    # self.pgconn.commit()
                    pgconn.commit()

                    # Это чтобы обновить атрибуты выбранных объектов
                    if self.mode == 'proc':
                        self.set_selected_proc_features_list()
                    elif self.mode == 'field':
                        self.set_selected_field_features_list()

                    # Это чтобы убрать лишние уведомления
                    [self.iface.messageBar().popWidget(x) for x in self.iface.messageBar().items()]

                    self.iface.messageBar().pushMessage('Запрос выполнен', self.sql,
                                                        level=Qgis.Success, duration=3)
                    # [self.iface.messageBar().popWidget(x) for x in self.iface.messageBar().items()]
        except:
            self.iface.messageBar().pushMessage('Запрос', f"{self.sql} не выполнен",
                                                level=Qgis.Critical, duration=5)

        self.sql = ''
        if self.mode == 'proc':
            self.refresh_processings()
            self.refresh_datasets()
            self.refresh_surveys()
        elif self.mode == 'field':
            self.refresh_surveys()


    def update_proc_for_selected_features(self):
        selected_cells = self.dockwind.procTableWidget.selectedItems()
        selected_rows = list(set([x.row() for x in selected_cells]))
        if len(selected_rows) != 1:
            self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать один проект по обработке', level=Qgis.Warning, duration=3)
        else:
            proc_id = self.proc_list[selected_rows[0]]['proc_id']
            # self.iface.messageBar().pushMessage('Информация', f"Выбрана обработка {str(proc_id)}", level=Qgis.Success, duration=5)
            if self.selectedProcLayer != None and len(self.selectedProcFeaturesList) > 0:
                if 'line_id' in [f.name() for f in self.selectedProcLayer.fields()]:
                    # self.iface.messageBar().pushMessage('Информация', f"Выбран слой с сейсмикой 2D",
                    #                                     level=Qgis.Success, duration=5)
                    if len(self.selectedProcFeaturesList) > 0:
                        line_id_list = [x['line_id'] for x in self.selectedProcFeaturesList]
                        sql = f"update {self.seismic_lines_processed_2d} set proc_id = {str(proc_id)} where line_id in ({', '.join([str(y) for y in line_id_list])});"
                        self.sql = sql

                        # self.iface.messageBar().pushMessage('Запрос', sql,
                        #                                     level=Qgis.Success, duration=5)
                        mwidget = self.iface.messageBar().createMessage(f"Изменить обработку для {len(line_id_list)} объектов?")
                        mbutton = QPushButton(mwidget)
                        mbutton.setText('Подтвердить')
                        mbutton.pressed.connect(self.execute_sql)
                        mwidget.layout().addWidget(mbutton)
                        self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=3)

                elif 'pol_id' in [f.name() for f in self.selectedProcLayer.fields()]:
                    # self.iface.messageBar().pushMessage('Информация', f"Выбран слой с сейсмикой 3D",
                    #                                     level=Qgis.Success, duration=5)
                    if len(self.selectedProcFeaturesList) > 0:
                        pol_id_list = [x['pol_id'] for x in self.selectedProcFeaturesList]
                        sql = f"update {self.seismic_pols_processed_3d} set proc_id = {str(proc_id)} where pol_id in ({', '.join([str(y) for y in pol_id_list])});"
                        self.sql = sql

                        # self.iface.messageBar().pushMessage('Запрос', sql,
                        #                                     level=Qgis.Success, duration=5)
                        mwidget = self.iface.messageBar().createMessage(
                            f"Изменить обработку для {len(pol_id_list)} объектов?")
                        mbutton = QPushButton(mwidget)
                        mbutton.setText('Подтвердить')
                        mbutton.pressed.connect(self.execute_sql)
                        mwidget.layout().addWidget(mbutton)
                        self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=3)
            else:
                self.iface.messageBar().pushMessage('Ошибка', f"Нужно выбрать слой и объекты в нем", level=Qgis.Warning, duration=5)


    def clear_proc_for_selected_geometry(self):
        # selected_cells = self.dockwind.procTableWidget.selectedItems()
        # selected_rows = list(set(x.row() for x in selected_cells))
        # if selected_rows:
        #     proc_ids = [self.proc_list[i]['proc_id'] for i in selected_rows]
        if self.selectedProcLayer and self.selectedProcFeaturesList and \
            any(['line_id' in [f.name() for f in self.selectedProcLayer.fields()],
                 'pol_id' in [f.name() for f in self.selectedProcLayer.fields()]]):
            if 'line_id' in [f.name() for f in self.selectedProcLayer.fields()]:
                glayer = self.seismic_lines_processed_2d
                gfield = 'line_id'
                table = self.seismic_lines_processed_2d
            else:
                glayer = self.seismic_pols_processed_3d
                gfield = 'pol_id'
                table = self.seismic_pols_processed_3d
            geom_ids = [x[gfield] for x in self.selectedProcFeaturesList]
            self.sql = f"update {glayer} set proc_id = NULL where {gfield} in ({', '.join([str(x) for x in geom_ids])});"
            mwidget = self.iface.messageBar().createMessage(
                f"Отвязать от обработки {str(len(geom_ids))} объектов в активном слое? Это приведет к обнулению поля 'Обработка' у этих объектов. "
                f"В дальнейшем Вы сможене привязать геометрию к другой обработке.")
            mbutton = QPushButton(mwidget)
            mbutton.setText('Подтвердить')
            mbutton.pressed.connect(self.execute_sql)
            mwidget.layout().addWidget(mbutton)
            self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=5)
        else:
            self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать хотя бы одну геометрию', level=Qgis.Warning, duration=5)
        # else:
        #     self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать хотя бы одну обработку и хотя бы одну геометрию', level=Qgis.Warning,
        #


    def display_selected_geometry_count(self):
        # if self.selectedProcFeaturesList:
        self.dockwind.selectedGeometryLabel.setText(f"Выбрано объектов: {len(self.selectedProcFeaturesList)}")

    def display_selected_field_geometry_count(self):
        # if self.selectedProcFeaturesList:
        self.dockwindfield.selectedGeometryLabel.setText(f"Выбрано объектов: {len(self.selectedFieldFeaturesList)}")


    def set_selected_field_features_list(self):
        selectedLayer = self.iface.layerTreeView().currentLayer()
        if selectedLayer:
            if selectedLayer.type() == QgsMapLayerType.VectorLayer:
                if all(['survey_id' in [f.name() for f in selectedLayer.fields()], selectedLayer.isSpatial()]):
                    self.selectedFieldLayer = selectedLayer
                    self.dockwindfield.selectedLayerLabel.setText(selectedLayer.name())
                    self.selectedFieldFeaturesList = self.selectedFieldLayer.selectedFeatures()
                    self.display_selected_field_geometry_count()
                else:
                    self.selectedFieldLayer = None
                    self.selectedFieldFeaturesList = []
                    self.dockwindfield.selectedLayerLabel.setText('Нужно выбрать векторный слой!')
            else:
                self.selectedFieldLayer = None
                self.selectedFieldFeaturesList = []
                self.dockwindfield.selectedLayerLabel.setText('Нужно выбрать векторный слой!')
                # self.iface.messageBar().pushMessage('Ошибка', 'Необходимо выбрать один слой в таблице содержания, содержащий геометрию обработанной сейсмики',
                #                                     level=Qgis.Warning, duration=3)
                self.display_selected_field_geometry_count()


    def set_selected_proc_features_list(self):
        selectedLayer = self.iface.layerTreeView().currentLayer()
        if selectedLayer:
            if selectedLayer.type() == QgsMapLayerType.VectorLayer:
                if all(['proc_id' in [f.name() for f in selectedLayer.fields()], selectedLayer.isSpatial()]):
                    self.selectedProcLayer = selectedLayer
                    self.dockwind.selectedLayerLabel.setText(selectedLayer.name())
                    self.selectedProcFeaturesList = self.selectedProcLayer.selectedFeatures()
                    self.display_selected_geometry_count()
                else:
                    self.selectedProcLayer = None
                    self.selectedProcFeaturesList = []
                    self.dockwind.selectedLayerLabel.setText('Нужно выбрать векторный слой!')
            else:
                self.selectedProcLayer = None
                self.selectedProcFeaturesList = []
                self.dockwind.selectedLayerLabel.setText('Нужно выбрать векторный слой!')
                # self.iface.messageBar().pushMessage('Ошибка', 'Необходимо выбрать один слой в таблице содержания, содержащий геометрию обработанной сейсмики',
                #                                     level=Qgis.Warning, duration=3)
                self.display_selected_geometry_count()


    def add_company(self):
        self.addcompdlg = AddCompDialog()

        def generate_sql():
            new_comp_name_full = self.addcompdlg.companyFullNameInput.text().replace("'", "''")
            new_comp_name_short = self.addcompdlg.companyShortNameInput.text().replace("'", "''")
            if len(new_comp_name_full.strip()) > 0 and len(new_comp_name_short.strip()) > 0:
                fields_to_update = 'name, shortname'
                values_to_insert = f"'{new_comp_name_full}', '{new_comp_name_short}'"
                self.sql = f"insert into {self.companies}({fields_to_update}) values({values_to_insert})"

        def insert_new_comp():
            new_comp_name_full = self.addcompdlg.companyFullNameInput.text()
            new_comp_name_short = self.addcompdlg.companyShortNameInput.text()
            if len(new_comp_name_full.strip()) > 0 and len(new_comp_name_short.strip()) > 0:
                mwidget = self.iface.messageBar().createMessage(f"Добавить в базу новую организацию {new_comp_name_full}?")
                mbutton = QPushButton(mwidget)
                mbutton.setText('Подтвердить')
                mbutton.pressed.connect(self.execute_sql)
                mbutton.pressed.connect(self.refresh_processings)
                mwidget.layout().addWidget(mbutton)
                self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=3)
                self.addcompdlg.accept()
            else:
                self.iface.messageBar().pushMessage('Ошибка', 'Укажите название и короткое название новой организации!',
                                                    level=Qgis.Warning,
                                                    duration=3)

        generate_sql()
        self.addcompdlg.companyFullNameInput.editingFinished.connect(generate_sql)
        self.addcompdlg.companyShortNameInput.editingFinished.connect(generate_sql)

        self.addcompdlg.insertCompanyButton.clicked.connect(insert_new_comp)

        self.addcompdlg.show()


    def add_project(self):
        self.addprojdlg = AddProjDialog()
        new_proj_name_ru = self.addprojdlg.projNameRuInput.text()
        new_proj_name_en = self.addprojdlg.projNameEnInput.text()

        def generate_sql():
            new_proj_name_ru = self.addprojdlg.projNameRuInput.text().replace("'", "''")
            new_proj_name_en = self.addprojdlg.projNameEnInput.text().replace("'", "''")
            if new_proj_name_ru and new_proj_name_en:
                fields_to_update = 'name_ru, name_en'
                values_to_insert = f"'{new_proj_name_ru}', '{new_proj_name_en}'"
                self.sql = f"insert into {self.projects}({fields_to_update}) values({values_to_insert})"
                # self.iface.messageBar().pushMessage('sql:', self.sql, level=Qgis.Success, duration=5)

        def insert_new_proj():
            new_proj_name_ru = self.addprojdlg.projNameRuInput.text()
            new_proj_name_en = self.addprojdlg.projNameEnInput.text()
            if new_proj_name_ru and new_proj_name_en:
                mwidget = self.iface.messageBar().createMessage(f"Добавить в базу новый проект {new_proj_name_ru}?")
                mbutton = QPushButton(mwidget)
                mbutton.setText('Подтвердить')
                mbutton.pressed.connect(self.execute_sql)
                mwidget.layout().addWidget(mbutton)
                self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=3)
                self.addprojdlg.accept()
            else:
                self.iface.messageBar().pushMessage('Ошибка', 'Укажите название нового проекта на всех языках', level=Qgis.Warning,
                                                    duration=3)

        generate_sql()
        self.addprojdlg.projNameRuInput.editingFinished.connect(generate_sql)
        self.addprojdlg.projNameEnInput.editingFinished.connect(generate_sql)

        self.addprojdlg.insertProjButton.clicked.connect(insert_new_proj)

        self.addprojdlg.show()


    def add_report(self):
        self.addreportdlg = AddReportDialog()
        self.addreportdlg.reportAuthorRefreshButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.addreportdlg.reportContractRefreshButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))

        def reload_report_data():
            self.addreportdlg.reportTypeInput.clear()
            self.addreportdlg.reportAuthorInput.clear()
            self.addreportdlg.reportConfInput.clear()
            self.addreportdlg.reportContractInput.clear()

            with open('.pgdsn', encoding='utf-8') as dsnf:
                dsn = dsnf.read().replace('\n', '')
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:

                # with self.pgconn.cursor() as cur:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.report_types}"
                    cur.execute(sql)
                    self.addreportdlg.report_types = list(cur.fetchall())
                    self.addreportdlg.reportTypeInput.addItems([row['name'] for row in self.addreportdlg.report_types])
                    sql = f"select * from {self.companies} order by name"
                    cur.execute(sql)
                    self.addreportdlg.companies = list(cur.fetchall())
                    self.addreportdlg.reportAuthorInput.addItem('')
                    self.addreportdlg.reportAuthorInput.addItems([row['name'] for row in self.addreportdlg.companies])
                    sql = f"select * from {self.contracts_view} order by name"
                    cur.execute(sql)
                    self.addreportdlg.contracts = list(cur.fetchall())
                    self.addreportdlg.reportContractInput.addItem('')
                    self.addreportdlg.reportContractInput.addItems([row['number'] + ' от ' + str(row['date']) for row in self.addreportdlg.contracts])
                    sql = f"select * from {self.conf}"
                    cur.execute(sql)
                    self.addreportdlg.conf = list(cur.fetchall())
                    self.addreportdlg.reportConfInput.addItem('')
                    self.addreportdlg.reportConfInput.addItems([row['conf_name'] for row in self.addreportdlg.conf])

        reload_report_data()

        def generate_sql():
            new_report_name = self.addreportdlg.reportNameInput.text().replace("'", "''")
            new_report_shortname = self.addreportdlg.reportShortNameInput.text().replace("'", "''")
            selected_report_type_index = self.addreportdlg.reportTypeInput.currentIndex()
            selected_report_type_id = self.addreportdlg.report_types[selected_report_type_index][1]
            selected_report_author_index = self.addreportdlg.reportAuthorInput.currentIndex() - 1
            new_report_year = str(self.addreportdlg.reportYearInput.value())
            selected_report_contract_index = self.addreportdlg.reportContractInput.currentIndex() - 1
            new_report_link = self.addreportdlg.reportLinkInput.text().replace("'", "''")
            selected_report_conf_index = self.addreportdlg.reportConfInput.currentIndex() - 1
            new_report_conf_limit = self.addreportdlg.reportConfLimitInput.text().replace("'", "''")
            fields_to_update = 'name, shortname, report_type_id, year'
            values_to_insert = f"'{new_report_name}', '{new_report_shortname}', {str(selected_report_type_id)}, {new_report_year}"
            if selected_report_author_index >= 0:
                fields_to_update += ', company_id'
                selected_report_author_id = self.addreportdlg.companies[selected_report_author_index][0]
                values_to_insert += f", {str(selected_report_author_id)}"
            if selected_report_contract_index >= 0:
                fields_to_update += ', contract_id'
                selected_report_contract_id = self.addreportdlg.contracts[selected_report_contract_index][1]
                values_to_insert += f", {str(selected_report_contract_id)}"
            if len(new_report_link.strip()) > 0:
                fields_to_update += ', link'
                values_to_insert += f", '{new_report_link}'"
            if selected_report_conf_index >= 0:
                fields_to_update += ', conf_id'
                selected_report_conf_id = self.addreportdlg.conf[selected_report_conf_index][1]
                values_to_insert += f", {str(selected_report_conf_id)}"
            if len(new_report_conf_limit.strip()) > 0:
                fields_to_update += ', conf_limit'
                values_to_insert += f", '{new_report_conf_limit}'"
            self.sql = f"insert into {self.reports}({fields_to_update}) values({values_to_insert})"

        def insert_new_report():
            new_report_name = self.addreportdlg.reportNameInput.text()
            new_report_shortname = self.addreportdlg.reportShortNameInput.text()
            if all([new_report_name.strip() != '', new_report_shortname.strip() != '']):
                mwidget = self.iface.messageBar().createMessage(f"Добавить в базу новый отчет {new_report_shortname}?")
                mbutton = QPushButton(mwidget)
                mbutton.setText('Подтвердить')
                mbutton.pressed.connect(self.execute_sql)
                mwidget.layout().addWidget(mbutton)
                self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=3)
                self.addreportdlg.accept()
            else:
                self.iface.messageBar().pushMessage('Ошибка', 'Укажите название и сокращенное название нового отчета', level=Qgis.Warning,
                                                    duration=3)

        generate_sql()

        self.addreportdlg.reportNameInput.editingFinished.connect(generate_sql)
        self.addreportdlg.reportShortNameInput.editingFinished.connect(generate_sql)
        self.addreportdlg.reportTypeInput.activated.connect(generate_sql)
        self.addreportdlg.reportAuthorInput.activated.connect(generate_sql)
        self.addreportdlg.reportAuthorRefreshButton.clicked.connect(reload_report_data)
        self.addreportdlg.reportAddAuthorButton.clicked.connect(self.add_company)
        self.addreportdlg.reportYearInput.valueChanged.connect(generate_sql)
        self.addreportdlg.reportYearInput.textChanged.connect(generate_sql)
        self.addreportdlg.reportContractInput.activated.connect(generate_sql)
        self.addreportdlg.reportContractRefreshButton.clicked.connect(reload_report_data)
        self.addreportdlg.reportAddContractButton.clicked.connect(self.add_contract)
        self.addreportdlg.reportLinkInput.editingFinished.connect(generate_sql)
        self.addreportdlg.reportConfInput.activated.connect(generate_sql)
        self.addreportdlg.reportConfLimitInput.editingFinished.connect(generate_sql)

        self.addreportdlg.insertReportButton.clicked.connect(insert_new_report)

        self.addreportdlg.show()


    def add_contract(self):
        self.addcontractdlg = AddContractDialog()
        self.addcontractdlg.contractCustomerRefreshButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.addcontractdlg.contractContractorRefreshButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))

        def reload_contract_data():
            # self.addcontractdlg.contractNumberInput.clear()
            # self.addcontractdlg.contractNameInput.clear()
            self.addcontractdlg.contractTypeInput.clear()
            self.addcontractdlg.contractCustomerInput.clear()
            self.addcontractdlg.contractContractorInput.clear()
            self.addcontractdlg.contractParentContractInput.clear()

            # with open('.pgdsn', encoding='utf-8') as dsnf:
            #     dsn = dsnf.read().replace('\n', '')
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:

                # with self.pgconn.cursor() as cur:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.contract_types}"
                    cur.execute(sql)
                    self.addcontractdlg.contract_types = list(cur.fetchall())
                    self.addcontractdlg.contractTypeInput.addItems([row['name'] for row in self.addcontractdlg.contract_types])
                    sql = f"select * from {self.companies} order by name"
                    cur.execute(sql)
                    self.addcontractdlg.companies = list(cur.fetchall())
                    self.addcontractdlg.contractCustomerInput.addItem('')
                    self.addcontractdlg.contractCustomerInput.addItems([row['name'] for row in self.addcontractdlg.companies])
                    self.addcontractdlg.contractContractorInput.addItem('')
                    self.addcontractdlg.contractContractorInput.addItems([row['name'] for row in self.addcontractdlg.companies])
                    sql = f"select * from {self.contracts_view} order by date DESC"
                    cur.execute(sql)
                    self.addcontractdlg.contracts = list(cur.fetchall())
                    self.addcontractdlg.contractParentContractInput.addItem('')
                    self.addcontractdlg.contractParentContractInput.addItems([row['number'] + ' от ' + str(row['date']) for row in self.addcontractdlg.contracts])

        reload_contract_data()

        def generate_sql():
            new_contract_number = self.addcontractdlg.contractNumberInput.text().replace("'", "''")
            new_contract_name = self.addcontractdlg.contractNameInput.text().replace("'", "''")
            selected_contract_type_index = self.addcontractdlg.contractTypeInput.currentIndex()
            selected_contract_type_id = self.addcontractdlg.contract_types[selected_contract_type_index][1]
            selected_contract_date = self.addcontractdlg.contractDateInput.dateTime()
            selected_customer_index = self.addcontractdlg.contractCustomerInput.currentIndex() - 1
            selected_contractor_index = self.addcontractdlg.contractContractorInput.currentIndex() - 1
            new_contract_link = self.addcontractdlg.contractLinkInput.text().replace("'", "''")
            selected_parent_contract_index = self.addcontractdlg.contractParentContractInput.currentIndex() - 1
            fields_to_update = 'number, name, contract_type_id, date'
            values_to_insert = f"'{new_contract_number}', '{new_contract_name}', '{selected_contract_type_id}', '{selected_contract_date.toString('yyyy-MM-dd')}'"
            if selected_customer_index >= 0:
                fields_to_update += ', customer_id'
                selected_customer_id = self.addcontractdlg.companies[selected_customer_index]['company_id']
                values_to_insert += f", {str(selected_customer_id)}"
            if selected_contractor_index >= 0:
                fields_to_update += ', contractor_id'
                selected_contractor_id = self.addcontractdlg.companies[selected_contractor_index]['company_id']
                values_to_insert += f", {str(selected_contractor_id)}"
            if len(new_contract_link) > 0:
                fields_to_update += ', link'
                values_to_insert += f", '{new_contract_link}'"
            if selected_parent_contract_index >= 0:
                fields_to_update += ', parent_contract_id'
                selected_parent_contract_id = self.addcontractdlg.contracts[selected_parent_contract_index]['contract_id']
                values_to_insert += f", {str(selected_parent_contract_id)}"
            self.sql = f"insert into {self.contracts}({fields_to_update}) values({values_to_insert})"
            # self.iface.messageBar().pushMessage('sql', self.sql, level=Qgis.Success, duration=5)

        def insert_new_contract():
            new_contract_number = self.addcontractdlg.contractNumberInput.text()
            new_contract_name = self.addcontractdlg.contractNameInput.text()
            selected_contract_type_index = self.addcontractdlg.contractTypeInput.currentIndex()
            selected_contract_type_id = self.addcontractdlg.contract_types[selected_contract_type_index][1]
            selected_contract_date = self.addcontractdlg.contractDateInput.dateTime()
            if all([
                len(new_contract_number.strip()) > 0,
                len(new_contract_name.strip()) > 0,
                selected_contract_type_id >= 0,
                selected_contract_date
            ]):
                mwidget = self.iface.messageBar().createMessage(f"Добавить в базу новый договор {new_contract_number}?")
                mbutton = QPushButton(mwidget)
                mbutton.setText('Подтвердить')
                mbutton.pressed.connect(self.execute_sql)
                mwidget.layout().addWidget(mbutton)
                self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=3)
                self.addcontractdlg.accept()
            else:
                self.iface.messageBar().pushMessage('Ошибка', 'Укажите номер, название, тип и дату нового договора',
                                                    level=Qgis.Warning, duration=3)

        generate_sql()
        self.addcontractdlg.contractNumberInput.editingFinished.connect(generate_sql)
        self.addcontractdlg.contractNameInput.editingFinished.connect(generate_sql)
        self.addcontractdlg.contractTypeInput.activated.connect(generate_sql)
        self.addcontractdlg.contractDateInput.dateTimeChanged.connect(generate_sql)
        self.addcontractdlg.contractCustomerInput.activated.connect(generate_sql)
        self.addcontractdlg.contractCustomerRefreshButton.clicked.connect(reload_contract_data)
        self.addcontractdlg.contractCustomerAddCompanyButton.clicked.connect(self.add_company)
        self.addcontractdlg.contractContractorInput.activated.connect(generate_sql)
        self.addcontractdlg.contractContractorRefreshButton.clicked.connect(reload_contract_data)
        self.addcontractdlg.contractContractorAddCompanyButton.clicked.connect(self.add_company)
        self.addcontractdlg.contractLinkInput.editingFinished.connect(generate_sql)
        self.addcontractdlg.contractParentContractInput.activated.connect(generate_sql)

        self.addcontractdlg.insertContractButton.clicked.connect(insert_new_contract)

        self.addcontractdlg.show()


    def add_proc(self):
        self.addprocdlg = AddProcDialog()
        self.addprocdlg.refreshProjButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.addprocdlg.refreshAuthorsButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.addprocdlg.refreshContractsButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.addprocdlg.refreshReportsButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))

        try:
            def reload_proc_data():
                self.addprocdlg.procTypeInput.clear()
                self.addprocdlg.projectInput.clear()
                self.addprocdlg.procAuthorInput.clear()
                self.addprocdlg.procContractInput.clear()
                self.addprocdlg.procReportInput.clear()

                # with open('.pgdsn', encoding='utf-8') as dsnf:
                #     dsn = dsnf.read().replace('\n', '')
                with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:

                    # with self.pgconn.cursor() as cur:
                    with pgconn.cursor() as cur:
                        sql = f"select * from {self.processing_types} order by id"
                        cur.execute(sql)
                        self.addprocdlg.proc_types = list(cur.fetchall())
                        self.addprocdlg.procTypeInput.addItems([row['name'] for row in self.addprocdlg.proc_types])
                        sql = f"select * from {self.projects}"
                        cur.execute(sql)
                        self.addprocdlg.projects = list(cur.fetchall())
                        self.addprocdlg.projectInput.addItems([row['name_ru'] for row in self.addprocdlg.projects])
                        sql = f"select * from {self.companies} order by name"
                        cur.execute(sql)
                        self.addprocdlg.companies = list(cur.fetchall())
                        self.addprocdlg.procAuthorInput.addItem('')
                        self.addprocdlg.procAuthorInput.addItems([row['name'] for row in self.addprocdlg.companies])
                        sql = f"select * from {self.contracts_view} order by date DESC"
                        cur.execute(sql)
                        self.addprocdlg.contracts = cur.fetchall()
                        self.addprocdlg.procContractInput.addItem('')
                        self.addprocdlg.procContractInput.addItems([row['number'] + ' от ' + str(row['date']) + ' ' + row['customer_short'] + '-' + row['contractor_short'] for row in self.addprocdlg.contracts])
                        sql = f"select * from {self.reports_view} order by shortname DESC"
                        cur.execute(sql)
                        self.addprocdlg.reports = cur.fetchall()
                        self.addprocdlg.procReportInput.addItem('')
                        self.addprocdlg.procReportInput.addItems([row['shortname'] for row in self.addprocdlg.reports])

            reload_proc_data()

            def generate_sql():
                new_proc_name = self.addprocdlg.procNameInput.text().replace("'", "''")
                new_proc_year = str(self.addprocdlg.procYearInput.value())
                selected_proc_type_index = self.addprocdlg.procTypeInput.currentIndex()
                selected_proc_type_id = self.addprocdlg.proc_types[selected_proc_type_index]['proc_type_id']
                selected_project_index = self.addprocdlg.projectInput.currentIndex()
                selected_project_id = self.addprocdlg.projects[selected_project_index]['id']
                selected_author_index = self.addprocdlg.procAuthorInput.currentIndex() - 1
                selected_contract_index = self.addprocdlg.procContractInput.currentIndex() - 1
                selected_report_index = self.addprocdlg.procReportInput.currentIndex() - 1
                fields_to_update = 'name, proc_type_id, year, project_id'
                values_to_insert = f"'{new_proc_name}', {str(selected_proc_type_id)}, {str(new_proc_year)}, {str(selected_project_id)}"
                if selected_author_index >= 0:
                    fields_to_update += ', author_id'
                    selected_author_id = self.addprocdlg.companies[selected_author_index]['company_id']
                    values_to_insert += f", {str(selected_author_id)}"
                if selected_contract_index >= 0:
                    fields_to_update += ', contract_id'
                    selected_contract_id = self.addprocdlg.contracts[selected_contract_index]['contract_id']
                    values_to_insert += f", {str(selected_contract_id)}"
                if selected_report_index >= 0:
                    fields_to_update += ', report_id'
                    selected_report_id = self.addprocdlg.reports[selected_report_index]['report_id']
                    values_to_insert += f", {str(selected_report_id)}"
                self.sql = f"insert into {self.processings}({fields_to_update}) values({values_to_insert})"
                # self.iface.messageBar().pushMessage('sql:', self.sql, level=Qgis.Success, duration=5)

            def insert_new_proc():
                new_proc_name = self.addprocdlg.procNameInput.text()
                if new_proc_name.strip() != '':
                    mwidget = self.iface.messageBar().createMessage(f"Добавить в базу новую обработку {new_proc_name}?")
                    mbutton = QPushButton(mwidget)
                    mbutton.setText('Подтвердить')
                    mbutton.pressed.connect(self.execute_sql)
                    mbutton.pressed.connect(self.refresh_processings)
                    mwidget.layout().addWidget(mbutton)
                    self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=3)
                    self.addprocdlg.accept()
                else:
                    self.iface.messageBar().pushMessage('Ошибка', 'Укажите название новой обработки', level=Qgis.Warning, duration=3)

            generate_sql()
            self.addprocdlg.procNameInput.editingFinished.connect(generate_sql)
            self.addprocdlg.procTypeInput.activated.connect(generate_sql)
            self.addprocdlg.projectInput.activated.connect(generate_sql)
            self.addprocdlg.procYearInput.valueChanged.connect(generate_sql)
            self.addprocdlg.procYearInput.textChanged.connect(generate_sql)
            self.addprocdlg.procAuthorInput.activated.connect(generate_sql)
            self.addprocdlg.procContractInput.activated.connect(generate_sql)
            self.addprocdlg.procReportInput.activated.connect(generate_sql)
            self.addprocdlg.addProjectButton.clicked.connect(self.add_project)
            self.addprocdlg.addCompanyButton.clicked.connect(self.add_company)
            self.addprocdlg.refreshProjButton.clicked.connect(reload_proc_data)
            self.addprocdlg.refreshAuthorsButton.clicked.connect(reload_proc_data)
            self.addprocdlg.refreshContractsButton.clicked.connect(reload_proc_data)
            self.addprocdlg.refreshReportsButton.clicked.connect(reload_proc_data)
            self.addprocdlg.addContractButton.clicked.connect(self.add_contract)
            self.addprocdlg.addReportButton.clicked.connect(self.add_report)

            # self.addprocdlg.insertProcButton.clicked.connect(self.addprocdlg.done())
            self.addprocdlg.insertProcButton.clicked.connect(insert_new_proc)

        except:
            self.iface.messageBar().pushMessage('Ошибка', 'Не удалось загрузить данные', level=Qgis.Warning, duration=3)

        self.addprocdlg.show()


    def delete_proc(self):
        selected_cells = self.dockwind.procTableWidget.selectedItems()
        selected_rows = list(set([x.row() for x in selected_cells]))
        if len(selected_rows) > 0:
            selected_proc_ids_list = [self.proc_list[i]['proc_id'] for i in selected_rows]
            self.sql = f"delete from {self.processings} where proc_id in ({', '.join([str(x) for x in selected_proc_ids_list])}); " \
                       f"update {self.seismic_lines_processed_2d} set proc_id = NULL where proc_id in ({', '.join([str(x) for x in selected_proc_ids_list])}); " \
                       f"update {self.seismic_pols_processed_3d} set proc_id = NULL where proc_id in ({', '.join([str(x) for x in selected_proc_ids_list])});"
            mwidget = self.iface.messageBar().createMessage(f"Удалить из базы обработки [{'], ['.join([self.proc_list[i]['name'] for i in selected_rows])}]? "
                                                            f"Это приведет к удалению ссылки на эту обработку "
                                                            f"из всех линий профилей 2D и полигонов площадок 3D")
            mbutton = QPushButton(mwidget)
            mbutton.setText('Подтвердить')
            mbutton.pressed.connect(self.execute_sql)
            mbutton.pressed.connect(self.refresh_processings)
            mwidget.layout().addWidget(mbutton)
            self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=10)
            # self.iface.messageBar().pushMessage('sql', self.sql, level=Qgis.Success, duration=3)
        else:
            self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать обработки для удаления', level=Qgis.Warning, duration=3)


    def update_proc(self):
        self.updateprocdlg = AddProcDialog()
        self.updateprocdlg.refreshProjButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.updateprocdlg.refreshAuthorsButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.updateprocdlg.refreshContractsButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.updateprocdlg.refreshReportsButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))

        def reload_proc_types():
            self.updateprocdlg.procTypeInput.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.processing_types} order by id"
                    cur.execute(sql)
                    self.updateprocdlg.proc_types = list(cur.fetchall())
                    self.updateprocdlg.procTypeInput.addItems([row[2] for row in self.updateprocdlg.proc_types])
                selected_proc_type = self.proc_list[self.updateprocdlg.selected_proc_row]['proc_type']
            if selected_proc_type:
                self.updateprocdlg.procTypeInput.setCurrentText(selected_proc_type)


        def reload_projects():
            self.updateprocdlg.projectInput.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.projects}"
                    cur.execute(sql)
                    self.updateprocdlg.projects = list(cur.fetchall())
                    self.updateprocdlg.projectInput.addItems([row[1] for row in self.updateprocdlg.projects])
                selected_project_id = self.proc_list[self.updateprocdlg.selected_proc_row]['project_id']
                if selected_project_id:
                    selected_project_name = [x for x in self.updateprocdlg.projects if x[0] == selected_project_id][0][1]
                    if selected_project_name:
                        self.updateprocdlg.projectInput.setCurrentText(selected_project_name)


        def reload_companies():
            self.updateprocdlg.procAuthorInput.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                sql = f"select * from {self.companies} order by name"
                with pgconn.cursor() as cur:
                    cur.execute(sql)
                    self.updateprocdlg.companies = list(cur.fetchall())
                    self.updateprocdlg.procAuthorInput.addItem('')
                    self.updateprocdlg.procAuthorInput.addItems([row[1] for row in self.updateprocdlg.companies])
                selected_author = self.proc_list[self.updateprocdlg.selected_proc_row]['company_name']
                if selected_author:
                    self.updateprocdlg.procAuthorInput.setCurrentText(selected_author)


        def reload_contracts():
            self.updateprocdlg.procContractInput.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.contracts_view} order by date DESC"
                    cur.execute(sql)
                    self.updateprocdlg.contracts = cur.fetchall()
                    self.updateprocdlg.procContractInput.addItem('')
                    self.updateprocdlg.procContractInput.addItems(
                        [row['number'] + ' от ' + str(row['date']) + ' ' + row['customer_short'] + '-' + row['contractor_short'] for row in
                         self.updateprocdlg.contracts])
                selected_contract_id = self.proc_list[self.updateprocdlg.selected_proc_row]['contract_id']
                if selected_contract_id:
                    selected_contract = [x for x in self.updateprocdlg.contracts if x['contract_id'] == selected_contract_id][0]
                    self.updateprocdlg.procContractInput.setCurrentText(
                        f"{selected_contract['number']} от {str(selected_contract['date'])} {selected_contract['customer_short']}-{selected_contract['contractor_short']}")


        def reload_reports():
            self.updateprocdlg.procReportInput.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.reports_view} order by shortname DESC"
                    cur.execute(sql)
                    self.updateprocdlg.reports = cur.fetchall()
                    self.updateprocdlg.procReportInput.addItem('')
                    self.updateprocdlg.procReportInput.addItems([row[3] for row in self.updateprocdlg.reports])
                selected_report = self.proc_list[self.updateprocdlg.selected_proc_row]['report_shortname']
                if selected_report:
                    self.updateprocdlg.procReportInput.setCurrentText(selected_report)


        def reload_proc_data():
            self.updateprocdlg.procTypeInput.clear()
            self.updateprocdlg.projectInput.clear()
            self.updateprocdlg.procAuthorInput.clear()
            self.updateprocdlg.procContractInput.clear()
            self.updateprocdlg.procReportInput.clear()

            # with open('.pgdsn', encoding='utf-8') as dsnf:
            #     dsn = dsnf.read().replace('\n', '')
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:

                # with self.pgconn.cursor() as cur:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.processing_types} order by id"
                    cur.execute(sql)
                    self.updateprocdlg.proc_types = list(cur.fetchall())
                    self.updateprocdlg.procTypeInput.addItems([row['name'] for row in self.updateprocdlg.proc_types])
                    sql = f"select * from {self.projects}"
                    cur.execute(sql)
                    self.updateprocdlg.projects = list(cur.fetchall())
                    self.updateprocdlg.projectInput.addItems([row['name_ru'] for row in self.updateprocdlg.projects])
                    sql = f"select * from {self.companies} order by name"
                    cur.execute(sql)
                    self.updateprocdlg.companies = list(cur.fetchall())
                    self.updateprocdlg.procAuthorInput.addItem('')
                    self.updateprocdlg.procAuthorInput.addItems([row['name'] for row in self.updateprocdlg.companies])
                    sql = f"select * from {self.contracts_view} order by date DESC"
                    cur.execute(sql)
                    self.updateprocdlg.contracts = cur.fetchall()
                    self.updateprocdlg.procContractInput.addItem('')
                    self.updateprocdlg.procContractInput.addItems(
                        [row['number'] + ' от ' + str(row['date']) + ' ' + row['customer_short'] + '-' + row['contractor_short'] for row in self.updateprocdlg.contracts])
                    sql = f"select * from {self.reports_view} order by shortname DESC"
                    cur.execute(sql)
                    self.updateprocdlg.reports = cur.fetchall()
                    self.updateprocdlg.procReportInput.addItem('')
                    self.updateprocdlg.procReportInput.addItems([row['shortname'] for row in self.updateprocdlg.reports])

        reload_proc_data()

        def fill_with_selected_proc():
            selected_proc_name = self.proc_list[self.updateprocdlg.selected_proc_row]['name']
            if selected_proc_name:
                self.updateprocdlg.procNameInput.setText(self.proc_list[self.updateprocdlg.selected_proc_row]['name'])

            selected_proc_type = self.proc_list[self.updateprocdlg.selected_proc_row]['proc_type']
            if selected_proc_type:
                self.updateprocdlg.procTypeInput.setCurrentText(selected_proc_type)

            selected_project_id = self.proc_list[self.updateprocdlg.selected_proc_row]['project_id']
            if selected_project_id:
                selected_project_name = [x for x in self.updateprocdlg.projects if x['id'] == selected_project_id][0]['name_ru']
                if selected_project_name:
                    self.updateprocdlg.projectInput.setCurrentText(selected_project_name)

            selected_proc_year = self.proc_list[self.updateprocdlg.selected_proc_row]['year']
            if selected_proc_year:
                self.updateprocdlg.procYearInput.setValue(selected_proc_year)

            selected_author = self.proc_list[self.updateprocdlg.selected_proc_row]['company_name']
            if selected_author:
                self.updateprocdlg.procAuthorInput.setCurrentText(selected_author)

            selected_contract_id =  self.proc_list[self.updateprocdlg.selected_proc_row]['contract_id']
            if selected_contract_id:
                selected_contract = [x for x in self.updateprocdlg.contracts if x['contract_id'] == selected_contract_id][0]
                self.updateprocdlg.procContractInput.setCurrentText(f"{selected_contract['number']} от {str(selected_contract['date'])} {selected_contract['customer_id']}-{selected_contract['contractor_id']}")

            selected_report = self.proc_list[self.updateprocdlg.selected_proc_row]['report_shortname']
            if selected_report:
                self.updateprocdlg.procReportInput.setCurrentText(selected_report)


        def generate_sql():
            selected_proc_id = self.proc_list[self.updateprocdlg.selected_proc_row]['proc_id']
            new_proc_name = self.updateprocdlg.procNameInput.text().replace("'", "''")
            new_proc_year = str(self.updateprocdlg.procYearInput.value())
            selected_proc_type_index = self.updateprocdlg.procTypeInput.currentIndex()
            selected_proc_type_id = self.updateprocdlg.proc_types[selected_proc_type_index]['proc_type_id']
            selected_project_index = self.updateprocdlg.projectInput.currentIndex()
            selected_project_id = self.updateprocdlg.projects[selected_project_index]['id']
            selected_author_index = self.updateprocdlg.procAuthorInput.currentIndex() - 1
            selected_contract_index = self.updateprocdlg.procContractInput.currentIndex() - 1
            selected_report_index = self.updateprocdlg.procReportInput.currentIndex() - 1
            fields_to_update = ['name', 'proc_type_id', 'year', 'project_id']
            values_to_update = [f"\'{new_proc_name}\'", str(selected_proc_type_id), str(new_proc_year), str(selected_project_id)]
            dict_to_update = dict(zip(fields_to_update, values_to_update))
            if selected_author_index >= 0:
                selected_author_id = self.updateprocdlg.companies[selected_author_index]['company_id']
                dict_to_update['author_id'] = str(selected_author_id)
            elif selected_author_index == -1:
                dict_to_update['author_id'] = self.null_value
            if selected_contract_index >= 0:
                selected_contract_id = self.updateprocdlg.contracts[selected_contract_index]['contract_id']
                dict_to_update['contract_id'] = str(selected_contract_id)
            elif selected_contract_index == -1:
                dict_to_update['contract_id'] = self.null_value
            if selected_report_index >= 0:
                selected_report_id = self.updateprocdlg.reports[selected_report_index]['report_id']
                dict_to_update['report_id'] = str(selected_report_id)
            elif selected_report_index == -1:
                dict_to_update['report_id'] = self.null_value
            self.sql = f"update {self.processings} set "
            self.sql += ', '.join([field + ' = ' + value for field, value in dict_to_update.items()])
            self.sql += f" where proc_id = {str(selected_proc_id)}"

        def update_the_proc():
            new_proc_name = self.updateprocdlg.procNameInput.text()
            if new_proc_name.strip() != '':
                mwidget = self.iface.messageBar().createMessage(f"Изменить обработку {new_proc_name}?")
                mbutton = QPushButton(mwidget)
                mbutton.setText('Подтвердить')
                mbutton.pressed.connect(self.execute_sql)
                mbutton.pressed.connect(self.refresh_processings)
                mwidget.layout().addWidget(mbutton)
                self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=3)
                self.updateprocdlg.accept()
            else:
                self.iface.messageBar().pushMessage('Ошибка', 'Укажите название обработки', level=Qgis.Warning,
                                                    duration=3)

        selected_proc_rows = list(set([x.row() for x in self.dockwind.procTableWidget.selectedItems()]))
        if len(selected_proc_rows) == 1:
            self.updateprocdlg.selected_proc_row = selected_proc_rows[0]
            self.updateprocdlg.setWindowTitle('Изменить обработку')
            self.updateprocdlg.insertProcButton.setText('Изменить обработку')
            fill_with_selected_proc()
            generate_sql()
            self.updateprocdlg.procNameInput.editingFinished.connect(generate_sql)
            self.updateprocdlg.procTypeInput.activated.connect(generate_sql)
            self.updateprocdlg.projectInput.activated.connect(generate_sql)
            self.updateprocdlg.procYearInput.valueChanged.connect(generate_sql)
            self.updateprocdlg.procYearInput.textChanged.connect(generate_sql)
            self.updateprocdlg.procAuthorInput.activated.connect(generate_sql)
            self.updateprocdlg.procContractInput.activated.connect(generate_sql)
            self.updateprocdlg.procReportInput.activated.connect(generate_sql)
            self.updateprocdlg.addProjectButton.clicked.connect(self.add_project)
            self.updateprocdlg.addCompanyButton.clicked.connect(self.add_company)
            self.updateprocdlg.refreshProjButton.clicked.connect(reload_projects)
            self.updateprocdlg.refreshAuthorsButton.clicked.connect(reload_companies)
            self.updateprocdlg.refreshContractsButton.clicked.connect(reload_contracts)
            self.updateprocdlg.refreshReportsButton.clicked.connect(reload_reports)
            self.updateprocdlg.addContractButton.clicked.connect(self.add_contract)
            self.updateprocdlg.addReportButton.clicked.connect(self.add_report)

            self.updateprocdlg.insertProcButton.clicked.connect(update_the_proc)

            self.updateprocdlg.show()
        else:
            self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать одну обработку', level=Qgis.Warning, duration=3)





    def select_proc_by_geometry(self):
        if self.selectedProcLayer != None and len(self.selectedProcFeaturesList) > 0:
            if 'proc_id' in [f.name() for f in self.selectedProcLayer.fields()]:
                selected_features_proc_ids_list = list(set([f.attribute('proc_id') for f in self.selectedProcFeaturesList]))
                selected_proc_indexes = [x[0] for x in enumerate(self.proc_list) if x[1]['proc_id'] in selected_features_proc_ids_list]
                [x.setSelected(False) for x in self.dockwind.procTableWidget.selectedItems()]
                # self.dockwind.procTableWidget.setSelectionMode(QAbstractItemView.MultiSelection)
                # [self.dockwind.procTableWidget.selectRow(i) for i in selected_proc_indexes]
                # self.dockwind.procTableWidget.setSelectionMode(QAbstractItemView.ContiguousSelection)
                if len(selected_features_proc_ids_list) > 0:
                    self.proc_id_filter = selected_features_proc_ids_list
                else:
                    self.proc_id_filter = [-1]
                self.refresh_processings()
                self.proc_id_filter = None
        else:
            self.iface.messageBar().pushMessage('Ошибка', f"Нужно выбрать слой и объекты в нем", level=Qgis.Warning,
                                                duration=5)

    def select_geometry_by_proc(self):
        selected_proc_rows = list(set([x.row() for x in self.dockwind.procTableWidget.selectedItems()]))
        selected_proc_ids = [str(self.proc_list[i]['proc_id']) for i in selected_proc_rows]
        if len(selected_proc_ids) > 0 and self.selectedProcLayer != None and 'proc_id' in [f.name() for f in self.selectedProcLayer.fields()]:
            proc_ids_string = ', '.join(selected_proc_ids)
            self.selectedProcLayer.removeSelection()
            self.selectedProcLayer.selectByExpression(f'"proc_id" in ({proc_ids_string})')
            if len(self.selectedProcLayer.selectedFeatures()) > 0:
                project_crs = QgsCoordinateReferenceSystem(QgsProject.instance().crs())
                layer_crs = self.selectedProcLayer.crs()
                lyr2proj = QgsCoordinateTransform(layer_crs, project_crs, QgsProject.instance())
                box = lyr2proj.transformBoundingBox(self.selectedProcLayer.boundingBoxOfSelected())
                self.iface.mapCanvas().setExtent(box)
                self.iface.mapCanvas().refresh()
        else:
            self.iface.messageBar().pushMessage('Ошибка', f"Нужно выбрать обработку(и) и слой с геометрией", level=Qgis.Warning, duration=5)


    def update_survey(self):
        selected_survey_rows = list(set([x.row() for x in self.wind.surveyTableWidget.selectedItems()]))
        if len(selected_survey_rows) == 1:
            self.updatesurveydlg = AddSurveyDialog()
            self.updatesurveydlg.refreshProjButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
            self.updatesurveydlg.refreshAuthorsButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
            self.updatesurveydlg.refreshContractsButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
            self.updatesurveydlg.refreshReportsButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
            self.updatesurveydlg.selected_survey_row = selected_survey_rows[0]
            self.updatesurveydlg.setWindowTitle('Изменить съемку')
            self.updatesurveydlg.insertSurveyButton.setText('Изменить съемку')
            self.updatesurveydlg.reports_to_link = []

            def reload_survey_name():
                self.updatesurveydlg.surveyNameInput.clear()
                self.updatesurveydlg.surveyNameInput.setText(self.surveys_view_list[self.updatesurveydlg.selected_survey_row]['name'])

            def reload_loc_types():
                self.updatesurveydlg.surveyLocTypeInput.clear()
                with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                    with pgconn.cursor() as cur:
                        sql = f"select * from {self.location_types}"
                        cur.execute(sql)
                        self.updatesurveydlg.location_types_list = cur.fetchall()
                        self.updatesurveydlg.surveyLocTypeInput.addItems([row['name'] for row in self.updatesurveydlg.location_types_list])
                    selected_loc_type = self.surveys_view_list[self.updatesurveydlg.selected_survey_row]['location_type']
                if selected_loc_type:
                    self.updatesurveydlg.surveyLocTypeInput.setCurrentText(selected_loc_type)

            def reload_survey_types():
                self.updatesurveydlg.surveyTypeInput.clear()
                with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                    with pgconn.cursor() as cur:
                        sql = f"select * from {self.survey_types}"
                        cur.execute(sql)
                        self.updatesurveydlg.survey_types_list = cur.fetchall()
                        self.updatesurveydlg.surveyTypeInput.addItems(
                            [row['name'] for row in self.updatesurveydlg.survey_types_list])
                    selected_survey_type = self.surveys_view_list[self.updatesurveydlg.selected_survey_row]['survey_type']
                if selected_survey_type:
                    self.updatesurveydlg.surveyTypeInput.setCurrentText(selected_survey_type)

            def reload_projects():
                self.updatesurveydlg.projectInput.clear()
                with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                    with pgconn.cursor() as cur:
                        sql = f"select * from {self.projects}"
                        cur.execute(sql)
                        self.updatesurveydlg.projects_list = cur.fetchall()
                        self.updatesurveydlg.projectInput.addItems(
                            [row['name_ru'] for row in self.updatesurveydlg.projects_list])
                        selected_survey_id = self.surveys_view_list[self.updatesurveydlg.selected_survey_row]['survey_id']
                        if selected_survey_id:
                            sql = f"select project_id from {self.surveys} where survey_id = {str(selected_survey_id)}"
                            cur.execute(sql)
                            selected_project_id = cur.fetchall()[0][0]
                            if selected_project_id:
                                selected_project_name = [x for x in self.updatesurveydlg.projects_list if x[0] == selected_project_id][0]['name_ru']
                                if selected_project_name:
                                    self.updatesurveydlg.projectInput.setCurrentText(selected_project_name)

            def reload_survey_year():
                year = self.surveys_view_list[self.updatesurveydlg.selected_survey_row]['year']
                if year:
                    self.updatesurveydlg.surveyYearInput.setValue(year)

            def reload_companies():
                filter_string = self.updatesurveydlg.authorFilterInput.text().strip().lower().replace("'", "''")
                self.updatesurveydlg.surveyAuthorInput.clear()
                with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                    with pgconn.cursor() as cur:
                        sql = f"select * from {self.companies}"
                        if filter_string:
                            sql += f" where LOWER(name) like '%{filter_string}%' " \
                                   f"or LOWER(shortname) like '%{filter_string}%'"
                        sql += " order by name"
                        cur.execute(sql)
                        self.updatesurveydlg.companies_list = list(cur.fetchall())
                        self.updatesurveydlg.surveyAuthorInput.addItem('')
                        self.updatesurveydlg.surveyAuthorInput.addItems([row['name'] for row in self.updatesurveydlg.companies_list])
                    selected_survey_author = self.surveys_view_list[self.updatesurveydlg.selected_survey_row]['acquisition_company']
                if selected_survey_author:
                    self.updatesurveydlg.surveyAuthorInput.setCurrentText(selected_survey_author)

            def reload_contracts():
                filter_string = self.updatesurveydlg.contractFilterInput.text().strip().lower().replace("'", "''")
                self.updatesurveydlg.surveyContractInput.clear()
                with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                    with pgconn.cursor() as cur:
                        sql = f"select * from {self.contracts_view}"
                        # f"or LOWER(name) like '%{filter_string}%' " \
                        if filter_string:
                            sql += f" where LOWER(number) like '%{filter_string}%' " \
                                   f"or LOWER(name) like '%{filter_string}%' " \
                                   f"or date::text like '%{filter_string}%' " \
                                   f"or LOWER(customer) like '%{filter_string}%' " \
                                   f"or LOWER(customer_short) like '%{filter_string}%' " \
                                   f"or LOWER(contractor) like '%{filter_string}%' " \
                                   f"or LOWER(contractor_short) like '%{filter_string}%'"
                        sql += " order by date DESC"
                        cur.execute(sql)
                        self.updatesurveydlg.contracts_list = cur.fetchall()
                        self.updatesurveydlg.surveyContractInput.addItem('')
                        self.updatesurveydlg.surveyContractInput.addItems([row['number'] + ' от ' + str(row['date']) + ' ' +
                                                                        row['customer_short'] + '-' + row[
                                                                            'contractor_short'] for row in
                                                                        self.updatesurveydlg.contracts_list])
                    selected_survey_contract_id = self.surveys_view_list[self.updatesurveydlg.selected_survey_row]['acquisition_contract_id']
                    if selected_survey_contract_id:
                        selected_survey_contracts = [x for x in self.updatesurveydlg.contracts_list if x['contract_id'] == selected_survey_contract_id]
                        if selected_survey_contracts:
                            selected_survey_contract = selected_survey_contracts[0]
                            self.updatesurveydlg.surveyAuthorInput.setCurrentText(f"{selected_survey_contract['number']} от "
                                                                                  f"{str(selected_survey_contract['date'])} "
                                                                                  f"{selected_survey_contract['customer_short']}-"
                                                                                  f"{selected_survey_contract['contractor_short']}")

            def reload_linked_reports():
                self.updatesurveydlg.surveyReportsTableWidget.clear()
                self.updatesurveydlg.surveyReportsTableWidget.setRowCount(0)
                self.updatesurveydlg.surveyReportsTableWidget.setColumnCount(2)
                self.updatesurveydlg.surveyReportsTableWidget.setHorizontalHeaderLabels(['Тип', 'Название'])
                header = self.updatesurveydlg.surveyReportsTableWidget.horizontalHeader()
                header.resizeSection(0, 100)
                header.resizeSection(1, 255)
                if self.updatesurveydlg.reports_to_link:
                    for i, report in enumerate(self.updatesurveydlg.reports_to_link):
                        self.updatesurveydlg.surveyReportsTableWidget.insertRow(i)
                        citem = QTableWidgetItem(report['report_type'])
                        citem.setToolTip(report['report_type'])
                        citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                        self.updatesurveydlg.surveyReportsTableWidget.setItem(i, 0, citem)
                        citem = QTableWidgetItem(report['shortname'])
                        citem.setToolTip(report['name'])
                        citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                        self.updatesurveydlg.surveyReportsTableWidget.setItem(i, 1, citem)

            def reload_reports():
                filter_string = self.updatesurveydlg.reportFilterInput.text().strip().lower().replace("'", "''")
                self.updatesurveydlg.surveyReportsInput.clear()
                self.updatesurveydlg.surveyReportsTableWidget.clearContents()
                sql = f"select * from {self.reports_view}"
                if filter_string:
                    sql += f" where LOWER(name) like '%{filter_string}%' " \
                           f"or LOWER(shortname) like '%{filter_string}%' " \
                           f"or LOWER(company_name) like '%{filter_string}%' " \
                           f"or LOWER(company_shortname) like '%{filter_string}%' " \
                           f"or LOWER(contract_number) like '%{filter_string}%' " \
                           f"or LOWER(contract_name) like '%{filter_string}%' " \
                           f"or year::text like '%{filter_string}%' " \
                           f"or LOWER(conf) like '%{filter_string}%' " \
                           f"or LOWER(conf_shortname) like '%{filter_string}%' " \
                           f"or LOWER(conf_limit) like '%{filter_string}%' " \
                           f"or LOWER(report_type) like '%{filter_string}%'"
                sql += " order by shortname DESC"
                with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                    with pgconn.cursor() as cur:
                        cur.execute(sql)
                        self.updatesurveydlg.all_reports_list = cur.fetchall()
                        self.updatesurveydlg.surveyReportsInput.addItem('Выберите отчет для привязки')
                        self.updatesurveydlg.surveyReportsInput.addItems(
                            [row['shortname'] for row in self.updatesurveydlg.all_reports_list])
                self.updatesurveydlg.surveyReportsTableWidget.setRowCount(0)
                self.updatesurveydlg.surveyReportsTableWidget.setColumnCount(2)
                self.updatesurveydlg.surveyReportsTableWidget.setHorizontalHeaderLabels(['Тип', 'Название'])
                header = self.updatesurveydlg.surveyReportsTableWidget.horizontalHeader()
                header.resizeSection(0, 100)
                header.resizeSection(1, 255)
                selected_survey_id = self.surveys_view_list[self.updatesurveydlg.selected_survey_row]['survey_id']
                if selected_survey_id:
                    sql = f"select report_id from {self.reports_to_surveys} where survey_id = {str(selected_survey_id)}"
                    with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                        with pgconn.cursor() as cur:
                            cur.execute(sql)
                            selected_report_ids = [x[0] for x in cur.fetchall()]
                            [self.updatesurveydlg.reports_to_link.append(x) for x in self.updatesurveydlg.all_reports_list if x['report_id'] in selected_report_ids and x not in self.updatesurveydlg.reports_to_link]
                            reload_linked_reports()

            def reload_survey_data():
                reload_survey_name()
                reload_loc_types()
                reload_survey_types()
                reload_projects()
                reload_survey_year()
                reload_companies()
                reload_contracts()
                reload_reports()

            reload_survey_data()

            def link_existing_report():
                selected_report_index = self.updatesurveydlg.surveyReportsInput.currentIndex() - 1
                if selected_report_index >= 0 and self.updatesurveydlg.all_reports_list[selected_report_index]['report_id'] not in \
                        [x['report_id'] for x in self.updatesurveydlg.reports_to_link]:
                    self.updatesurveydlg.reports_to_link.append(self.updatesurveydlg.all_reports_list[selected_report_index])
                    reload_linked_reports()
                self.updatesurveydlg.surveyReportsInput.setCurrentIndex(0)

            def unlink_existing_report():
                selected_reports_rows = list(set([x.row() for x in self.updatesurveydlg.surveyReportsTableWidget.selectedItems()]))
                if selected_reports_rows:
                    self.updatesurveydlg.reports_to_link = [x for x in self.updatesurveydlg.reports_to_link if
                                                               self.updatesurveydlg.reports_to_link.index(
                                                                   x) not in selected_reports_rows]
                    reload_linked_reports()

            def generate_and_execute_sql():
                selected_survey_id = self.surveys_view_list[self.updatesurveydlg.selected_survey_row]['survey_id']
                new_survey_name = self.updatesurveydlg.surveyNameInput.text().replace("'", "''")
                selected_loc_type_index = self.updatesurveydlg.surveyLocTypeInput.currentIndex()
                selected_loc_type_id = self.updatesurveydlg.location_types_list[selected_loc_type_index]['location_type_id']
                selected_survey_type_index = self.updatesurveydlg.surveyTypeInput.currentIndex()
                selected_survey_type_id = self.updatesurveydlg.survey_types_list[selected_survey_type_index]['survey_type_id']
                selected_project_index = self.updatesurveydlg.projectInput.currentIndex()
                selected_project_id = self.updatesurveydlg.projects_list[selected_project_index]['id']
                new_survey_year = str(self.updatesurveydlg.surveyYearInput.value())
                selected_author_index = self.updatesurveydlg.surveyAuthorInput.currentIndex() - 1
                selected_contract_index = self.updatesurveydlg.surveyContractInput.currentIndex() - 1
                fields_to_update = ['name', 'location_type_id', 'type_id', 'project_id', 'year']
                values_to_update = [f"'{new_survey_name}'", str(selected_loc_type_id), str(selected_survey_type_id), str(selected_project_id), str(new_survey_year)]
                if selected_author_index >= 0:
                    fields_to_update.append('acquisition_company_id')
                    selected_author_id = self.updatesurveydlg.companies_list[selected_author_index]['company_id']
                    values_to_update.append(str(selected_author_id))
                if selected_contract_index >= 0:
                    fields_to_update.append('acquisition_contract_id')
                    selected_contract_id = self.updatesurveydlg.contracts_list[selected_contract_index]['contract_id']
                    values_to_update.append(str(selected_contract_id))
                fields_values = ', '.join([a[0] + ' = ' + a[1] for a in zip(fields_to_update, values_to_update)])
                self.sql = f"update {self.surveys} set {fields_values} where survey_id = {selected_survey_id};"
                self.sql += f" delete from {self.reports_to_surveys} where survey_id = {selected_survey_id};"
                if self.updatesurveydlg.reports_to_link:
                    # self.sql += f" delete from {self.reports_to_surveys} where survey_id = {selected_survey_id};"
                    self.sql += f" insert into {self.reports_to_surveys}(report_id, survey_id) " \
                                f"values{', '.join(['(' + str(x['report_id']) + ', ' + str(selected_survey_id) + ')' for x in self.updatesurveydlg.reports_to_link])};"
                # self.iface.messageBar().pushMessage('sql', self.sql, level=Qgis.Success, duration=5)
                mwidget = self.iface.messageBar().createMessage(
                    f"Изменить данные съемки {new_survey_name}?")
                mbutton = QPushButton(mwidget)
                mbutton.setText('Подтвердить')
                mbutton.pressed.connect(self.execute_sql)
                mbutton.pressed.connect(self.refresh_surveys)
                mwidget.layout().addWidget(mbutton)
                self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=5)
                self.updatesurveydlg.accept()

            self.updatesurveydlg.addProjectButton.clicked.connect(self.add_project)
            self.updatesurveydlg.refreshProjButton.clicked.connect(reload_projects)
            self.updatesurveydlg.addCompanyButton.clicked.connect(self.add_company)
            self.updatesurveydlg.authorFilterInput.textEdited.connect(reload_companies)
            self.updatesurveydlg.refreshAuthorsButton.clicked.connect(reload_companies)
            self.updatesurveydlg.addContractButton.clicked.connect(self.add_contract)
            self.updatesurveydlg.contractFilterInput.textEdited.connect(reload_contracts)
            self.updatesurveydlg.refreshContractsButton.clicked.connect(reload_contracts)
            self.updatesurveydlg.addReportButton.clicked.connect(self.add_report)
            self.updatesurveydlg.reportFilterInput.textEdited.connect(reload_reports)
            self.updatesurveydlg.refreshReportsButton.clicked.connect(reload_reports)
            self.updatesurveydlg.surveyReportsInput.activated.connect(link_existing_report)
            self.updatesurveydlg.unlinkSelectedReportButton.clicked.connect(unlink_existing_report)
            self.updatesurveydlg.insertSurveyButton.clicked.connect(generate_and_execute_sql)
            self.updatesurveydlg.show()

        else:
            self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать одну съемку', level=Qgis.Warning, duration=3)


    def add_survey(self):
        self.addsurveydlg = AddSurveyDialog()
        self.addsurveydlg.refreshProjButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.addsurveydlg.refreshAuthorsButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.addsurveydlg.refreshContractsButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.addsurveydlg.refreshReportsButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))

        self.addsurveydlg.reports_to_link = []

        def reload_survey_data():
            self.addsurveydlg.surveyTypeInput.clear()
            self.addsurveydlg.projectInput.clear()
            self.addsurveydlg.surveyAuthorInput.clear()
            self.addsurveydlg.surveyContractInput.clear()
            self.addsurveydlg.surveyLocTypeInput.clear()
            self.addsurveydlg.surveyReportsTableWidget.clear()
            self.addsurveydlg.surveyReportsInput.clear()

            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.location_types}"
                    cur.execute(sql)
                    self.addsurveydlg.location_types_list = cur.fetchall()
                    self.addsurveydlg.surveyLocTypeInput.addItems([row['name'] for row in self.addsurveydlg.location_types_list])

                    sql = f"select * from {self.survey_types} order by survey_type_id"
                    cur.execute(sql)
                    self.addsurveydlg.survey_types_list = list(cur.fetchall())
                    self.addsurveydlg.surveyTypeInput.addItems([row['name'] for row in self.addsurveydlg.survey_types_list])

                    sql = f"select * from {self.projects}"
                    cur.execute(sql)
                    self.addsurveydlg.projects_list = list(cur.fetchall())
                    self.addsurveydlg.projectInput.addItems([row['name_ru'] for row in self.addsurveydlg.projects_list])

                    sql = f"select * from {self.companies} order by name"
                    cur.execute(sql)
                    self.addsurveydlg.companies_list = list(cur.fetchall())
                    self.addsurveydlg.surveyAuthorInput.addItem('')
                    self.addsurveydlg.surveyAuthorInput.addItems([row['name'] for row in self.addsurveydlg.companies_list])

                    sql = f"select * from {self.contracts_view} order by date DESC"
                    cur.execute(sql)
                    self.addsurveydlg.contracts_list = cur.fetchall()
                    self.addsurveydlg.surveyContractInput.addItem('')
                    self.addsurveydlg.surveyContractInput.addItems([row['number'] + ' от ' + str(row['date']) + ' ' + row['customer_short'] + '-' + row['contractor_short'] for row in self.addsurveydlg.contracts_list])

                    sql = f"select * from {self.reports_view} order by shortname DESC"
                    cur.execute(sql)
                    self.addsurveydlg.all_reports_list = cur.fetchall()
                    self.addsurveydlg.surveyReportsInput.addItem('Выберите отчет для привязки')
                    self.addsurveydlg.surveyReportsInput.addItems([row['shortname'] for row in self.addsurveydlg.all_reports_list])
                    self.addsurveydlg.surveyReportsTableWidget.clear()
                    self.addsurveydlg.surveyReportsTableWidget.setRowCount(0)
                    self.addsurveydlg.surveyReportsTableWidget.setColumnCount(2)
                    self.addsurveydlg.surveyReportsTableWidget.setHorizontalHeaderLabels(['Тип', 'Название'])
                    header = self.addsurveydlg.surveyReportsTableWidget.horizontalHeader()
                    header.resizeSection(0, 100)
                    header.resizeSection(1, 255)

        def reload_projects():
            self.addsurveydlg.projectInput.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.projects}"
                    cur.execute(sql)
                    self.addsurveydlg.projects_list = list(cur.fetchall())
                    self.addsurveydlg.projectInput.addItems([row['name_ru'] for row in self.addsurveydlg.projects_list])

        def reload_companies():
            filter_string = self.addsurveydlg.authorFilterInput.text().strip().lower().replace("'", "''")
            self.addsurveydlg.surveyAuthorInput.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.companies}"
                    if filter_string:
                        sql += f" where LOWER(name) like '%{filter_string}%' " \
                               f"or LOWER(shortname) like '%{filter_string}%'"
                    sql += " order by name"
                    cur.execute(sql)
                    self.addsurveydlg.companies_list = list(cur.fetchall())
                    self.addsurveydlg.surveyAuthorInput.addItem('')
                    self.addsurveydlg.surveyAuthorInput.addItems([row['name'] for row in self.addsurveydlg.companies_list])

        def reload_contracts():
            filter_string = self.addsurveydlg.contractFilterInput.text().strip().lower().replace("'", "''")
            self.addsurveydlg.surveyContractInput.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.contracts_view}"
                    # f"or LOWER(name) like '%{filter_string}%' " \
                    if filter_string:
                        sql += f" where LOWER(number) like '%{filter_string}%' " \
                               f"or LOWER(name) like '%{filter_string}%' " \
                               f"or date::text like '%{filter_string}%' " \
                               f"or LOWER(customer) like '%{filter_string}%' " \
                               f"or LOWER(customer_short) like '%{filter_string}%' " \
                               f"or LOWER(contractor) like '%{filter_string}%' " \
                               f"or LOWER(contractor_short) like '%{filter_string}%'"
                    sql += " order by date DESC"
                    cur.execute(sql)
                    self.addsurveydlg.contracts_list = cur.fetchall()
                    self.addsurveydlg.surveyContractInput.addItem('')
                    self.addsurveydlg.surveyContractInput.addItems([row['number'] + ' от ' + str(row['date']) + ' ' +
                                                                    row['customer_short'] + '-' + row[
                                                                        'contractor_short'] for row in
                                                                    self.addsurveydlg.contracts_list])

        def reload_reports():
            filter_string = self.addsurveydlg.reportFilterInput.text().strip().lower().replace("'", "''")
            self.addsurveydlg.surveyReportsInput.clear()
            sql = f"select * from {self.reports_view}"
            if filter_string:
                sql += f" where LOWER(name) like '%{filter_string}%' " \
                       f"or LOWER(shortname) like '%{filter_string}%' " \
                       f"or LOWER(company_name) like '%{filter_string}%' " \
                       f"or LOWER(company_shortname) like '%{filter_string}%' " \
                       f"or LOWER(contract_number) like '%{filter_string}%' " \
                       f"or LOWER(contract_name) like '%{filter_string}%' " \
                       f"or year::text like '%{filter_string}%' " \
                       f"or LOWER(conf) like '%{filter_string}%' " \
                       f"or LOWER(conf_shortname) like '%{filter_string}%' " \
                       f"or LOWER(conf_limit) like '%{filter_string}%' " \
                       f"or LOWER(report_type) like '%{filter_string}%'"
            sql += " order by shortname DESC"
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    cur.execute(sql)
                    self.addsurveydlg.all_reports_list = cur.fetchall()
                    self.addsurveydlg.surveyReportsInput.addItem('Выберите отчет для привязки')
                    self.addsurveydlg.surveyReportsInput.addItems([row['shortname'] for row in self.addsurveydlg.all_reports_list])

        reload_survey_data()

        def link_existing_report():
            selected_report_index = self.addsurveydlg.surveyReportsInput.currentIndex() - 1
            if selected_report_index >= 0 and self.addsurveydlg.all_reports_list[selected_report_index]['report_id'] not in \
                    [x['report_id'] for x in self.addsurveydlg.reports_to_link]:
                self.addsurveydlg.reports_to_link.append(self.addsurveydlg.all_reports_list[selected_report_index])
                i = self.addsurveydlg.surveyReportsTableWidget.rowCount()
                self.addsurveydlg.surveyReportsTableWidget.insertRow(i)
                citem = QTableWidgetItem(self.addsurveydlg.all_reports_list[selected_report_index]['report_type'])
                citem.setToolTip(self.addsurveydlg.all_reports_list[selected_report_index]['report_type'])
                citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.addsurveydlg.surveyReportsTableWidget.setItem(i, 0, citem)
                citem = QTableWidgetItem(self.addsurveydlg.all_reports_list[selected_report_index]['shortname'])
                citem.setToolTip(self.addsurveydlg.all_reports_list[selected_report_index]['name'])
                citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.addsurveydlg.surveyReportsTableWidget.setItem(i, 1, citem)
            self.addsurveydlg.surveyReportsInput.setCurrentIndex(0)

        def unlink_existing_report():
            selected_reports_rows = list(set([x.row() for x in self.addsurveydlg.surveyReportsTableWidget.selectedItems()]))
            if selected_reports_rows:
                [self.addsurveydlg.reports_to_link.pop(x) for x in selected_reports_rows]
                [self.addsurveydlg.surveyReportsTableWidget.removeRow(x) for x in selected_reports_rows]

        def generate_and_execute_sql():
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from nextval('{self.survey_id_seq}'::regclass)"
                    cur.execute(sql)
                    new_survey_id = cur.fetchall()[0][0]
            new_survey_name = self.addsurveydlg.surveyNameInput.text().replace("'", "''")
            selected_loc_type_index = self.addsurveydlg.surveyLocTypeInput.currentIndex()
            selected_loc_type_id = self.addsurveydlg.location_types_list[selected_loc_type_index]['location_type_id']
            selected_survey_type_index = self.addsurveydlg.surveyTypeInput.currentIndex()
            selected_survey_type_id = self.addsurveydlg.survey_types_list[selected_survey_type_index]['survey_type_id']
            selected_project_index = self.addsurveydlg.projectInput.currentIndex()
            selected_project_id = self.addsurveydlg.projects_list[selected_project_index]['id']
            new_survey_year = str(self.addsurveydlg.surveyYearInput.value())
            selected_author_index = self.addsurveydlg.surveyAuthorInput.currentIndex() - 1
            selected_contract_index = self.addsurveydlg.surveyContractInput.currentIndex() - 1
            fields_to_update = 'survey_id, name, location_type_id, type_id, project_id, year'
            values_to_insert = f"{str(new_survey_id)}, '{new_survey_name}', {str(selected_loc_type_id)}, {str(selected_survey_type_id)}, {str(selected_project_id)}, {str(new_survey_year)}"
            if selected_author_index >= 0:
                fields_to_update += ', acquisition_company_id'
                selected_author_id = self.addsurveydlg.companies_list[selected_author_index]['company_id']
                values_to_insert += f", {str(selected_author_id)}"
            if selected_contract_index >= 0:
                fields_to_update += ', acquisition_contract_id'
                selected_contract_id = self.addsurveydlg.contracts_list[selected_contract_index]['contract_id']
                values_to_insert += f", {str(selected_contract_id)}"
            self.sql = f"insert into {self.surveys}({fields_to_update}) values({values_to_insert})"
            for i, report in enumerate(self.addsurveydlg.reports_to_link):
                if i == 0:
                    self.sql += f"; insert into {self.reports_to_surveys}(report_id, survey_id) values({str(report['report_id'])}, {str(new_survey_id)})"
                elif i > 0:
                    self.sql += f", ({str(report['report_id'])}, {str(new_survey_id)})"
            self.sql += ';'
            # self.iface.messageBar().pushMessage('sql', self.sql, level=Qgis.Success, duration=5)
            mwidget = self.iface.messageBar().createMessage(
                f"Добавить в базу съемку {str(new_survey_name)}?")
            mbutton = QPushButton(mwidget)
            mbutton.setText('Подтвердить')
            mbutton.pressed.connect(self.execute_sql)
            mbutton.pressed.connect(self.refresh_surveys)
            mwidget.layout().addWidget(mbutton)
            self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=5)
            self.addsurveydlg.accept()
        self.addsurveydlg.addProjectButton.clicked.connect(self.add_project)
        self.addsurveydlg.refreshProjButton.clicked.connect(reload_projects)
        self.addsurveydlg.addCompanyButton.clicked.connect(self.add_company)
        self.addsurveydlg.authorFilterInput.textEdited.connect(reload_companies)
        self.addsurveydlg.refreshAuthorsButton.clicked.connect(reload_companies)
        self.addsurveydlg.addContractButton.clicked.connect(self.add_contract)
        self.addsurveydlg.contractFilterInput.textEdited.connect(reload_contracts)
        self.addsurveydlg.refreshContractsButton.clicked.connect(reload_contracts)
        self.addsurveydlg.addReportButton.clicked.connect(self.add_report)
        self.addsurveydlg.reportFilterInput.textEdited.connect(reload_reports)
        self.addsurveydlg.refreshReportsButton.clicked.connect(reload_reports)
        self.addsurveydlg.surveyReportsInput.activated.connect(link_existing_report)
        self.addsurveydlg.unlinkSelectedReportButton.clicked.connect(unlink_existing_report)
        self.addsurveydlg.insertSurveyButton.clicked.connect(generate_and_execute_sql)
        self.addsurveydlg.show()


    def delete_survey(self):
        selected_cells = self.wind.surveyTableWidget.selectedItems()
        selected_rows = list(set([x.row() for x in selected_cells]))
        if selected_rows:
            selected_survey_ids_list = [self.surveys_view_list[i]['survey_id'] for i in selected_rows]
            self.sql = f"delete from {self.surveys} where survey_id in ({', '.join([str(x) for x in selected_survey_ids_list])});" \
                       f" delete from {self.proc_geom_to_surveys} where survey_id in ({', '.join([str(x) for x in selected_survey_ids_list])});" \
                       f" delete from {self.reports_to_surveys} where survey_id in ({', '.join([str(x) for x in selected_survey_ids_list])});" \
                       f" update {self.seismic_lines_field_2d} set survey_id = NULL where survey_id in ({', '.join([str(x) for x in selected_survey_ids_list])});" \
                       f" update {self.seismic_pols_field_3d} set survey_id = NULL where survey_id in ({', '.join([str(x) for x in selected_survey_ids_list])});"
            mwidget = self.iface.messageBar().createMessage(f"Удалить из базы съемки {', '.join(['[' + x['name'] + ']' for x in [self.surveys_view_list[i] for i in selected_rows]])}? "
                                                            f"Это приведет к удалению их связей со всеми профилями, площадками, отчетами и другими связанными объектами.")
            mbutton = QPushButton(mwidget)
            mbutton.setText('Подтвердить')
            mbutton.pressed.connect(self.execute_sql)
            mbutton.pressed.connect(self.refresh_surveys)
            mwidget.layout().addWidget(mbutton)
            self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=5)


    def get_datasets_from_postgres(self):
        if self.mode == 'proc':
            selected_proc_rows = list(set([x.row() for x in self.wind.procTableWidget.selectedItems()]))
    
            # if selected_proc_rows:
            if selected_proc_rows:
                selected_proc_ids_string = ', '.join([str(self.proc_list[x]['proc_id']) for x in selected_proc_rows])
            sql = f"select * from {self.seismic_datasets_view}"
            if self.show_datasets_for_selected_proc:
                if selected_proc_rows:
                    sql += f" where dataset_id in " \
                           f"(select dataset_id from {self.datasets_to_geometries} " \
                            f"where geometry_id in (select line_id from {self.seismic_lines_processed_2d} where proc_id in ({selected_proc_ids_string})) " \
                            f" or geometry_id in (select pol_id from {self.seismic_pols_processed_3d} where proc_id in ({selected_proc_ids_string})))"
                else:
                    return False
            filter_str = self.wind.datasetFilterLineEdit.text().lower().strip()
            if filter_str:
                if self.show_datasets_for_selected_proc:
                    if selected_proc_rows:
                        sql += f" and (LOWER(datasource_type) like '%{filter_str}%'"
                    else:
                        return False
                else:
                    sql += f" where (LOWER(datasource_type) like '%{filter_str}%'"
                sql += f" or LOWER(shortname) like '%{filter_str}%'" \
                   f" or LOWER(name) like '%{filter_str}%'" \
                   f" or LOWER(seismic_type) like '%{filter_str}%'" \
                   f" or LOWER(format) like '%{filter_str}%'" \
                   f" or LOWER(data_quality) like '%{filter_str}%')"
            if self.dataset_id_filter:
                if self.show_datasets_for_selected_proc:
                    sql += f" and dataset_id in ({', '.join([str(x) for x in self.dataset_id_filter])})"
                else:
                    sql += f" where dataset_id in ({', '.join([str(x) for x in self.dataset_id_filter])})"
            if any([self.dataset_id_filter, filter_str, self.show_datasets_for_selected_proc]):
                sql += ' and'
            else:
                sql += ' where'
            sql += f" dataset_id in (select dataset_id from {self.datasets_to_geometries} where geometry_id in (select line_id from {self.seismic_lines_processed_2d}) or geometry_id in (select pol_id from {self.seismic_pols_processed_3d}))"
            sql += ' order by dataset_id;'
        elif self.mode == 'field':
            selected_survey_rows = list(set([x.row() for x in self.wind.surveyTableWidget.selectedItems()]))
            if selected_survey_rows:
                selected_survey_ids_string = ', '.join([str(self.surveys_view_list[x]['survey_id']) for x in selected_survey_rows])
            sql = f"select * from {self.seismic_datasets_view}"
            if self.show_datasets_for_selected_surveys:
                if selected_survey_rows:
                    sql += f" where dataset_id in " \
                           f"(select dataset_id from {self.datasets_to_geometries} " \
                           f"where geometry_id in (select field_line_id from {self.seismic_lines_field_2d} where survey_id in ({selected_survey_ids_string})) " \
                           f" or geometry_id in (select pol_id from {self.seismic_pols_field_3d} where survey_id in ({selected_survey_ids_string})))"
                else:
                    return False
            filter_str = self.wind.datasetFilterLineEdit.text().lower().strip()
            if filter_str:
                if self.show_datasets_for_selected_surveys:
                    if selected_survey_rows:
                        sql += f" and (LOWER(datasource_type) like '%{filter_str}%'"
                    else:
                        return False
                else:
                    sql += f" where (LOWER(datasource_type) like '%{filter_str}%'"
                sql += f" or LOWER(shortname) like '%{filter_str}%'" \
                       f" or LOWER(name) like '%{filter_str}%'" \
                       f" or LOWER(seismic_type) like '%{filter_str}%'" \
                       f" or LOWER(format) like '%{filter_str}%'" \
                       f" or LOWER(data_quality) like '%{filter_str}%')"
            if self.dataset_id_filter:
                if self.show_datasets_for_selected_surveys:
                    sql += f" and dataset_id in ({', '.join([str(x) for x in self.dataset_id_filter])})"
                else:
                    sql += f" where dataset_id in ({', '.join([str(x) for x in self.dataset_id_filter])})"
            if any([self.show_datasets_for_selected_surveys, filter_str, self.dataset_id_filter]):
                sql += ' and'
            else:
                sql += ' where'
            sql += f" dataset_id in (select dataset_id from {self.datasets_to_geometries} where geometry_id in (select field_line_id from {self.seismic_lines_field_2d}) or geometry_id in (select pol_id from {self.seismic_pols_field_3d}))"
            sql += ' order by dataset_id;'
        try:
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                if pgconn:
                    with pgconn.cursor() as cur:
                        cur.execute(sql)
                        self.seismic_datasets_view_list = list(cur.fetchall())
                        sql = f"select dataset_id, geometry_id from {self.datasets_to_geometries}"
                        cur.execute(sql)
                        self.datasets_to_geometries_list = list(cur.fetchall())
                        return True
                else:
                    self.iface.messageBar().pushMessage('Ошибка', 'Не удалось загрузить сведения о наборах данных из базы ' + sql,
                                                        level=Qgis.Critical, duration=5)
                    return False
        except:
            self.iface.messageBar().pushMessage('Ошибка', 'Не удалось загрузить сведения о наборах данных из базы ' + sql,
                                                level=Qgis.Critical, duration=5)
            return False

    def refresh_datasets(self):
        self.wind.datasetTableWidget.clear()
        self.wind.datasetTableWidget.setRowCount(0)
        self.wind.datasetTableWidget.setColumnCount(3)
        self.wind.datasetTableWidget.setHorizontalHeaderLabels(['Название', 'Тип', 'формат'])
        header = self.wind.datasetTableWidget.horizontalHeader()
        header.resizeSection(0, 100)
        header.resizeSection(1, 200)
        header.resizeSection(2, 50)
        if self.get_datasets_from_postgres():
            for i, dataset_row in enumerate(self.seismic_datasets_view_list):
                self.wind.datasetTableWidget.insertRow(i)
                citem = QTableWidgetItem(dataset_row['shortname'])
                citem.setToolTip(str(dataset_row['name']))
                citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.wind.datasetTableWidget.setItem(i, 0, citem)
                citem = QTableWidgetItem(dataset_row['seismic_type'])
                citem.setToolTip(str(dataset_row['seismic_type']))
                citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.wind.datasetTableWidget.setItem(i, 1, citem)
                citem = QTableWidgetItem(dataset_row['format'])
                citem.setToolTip(str(dataset_row['format']))
                citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                self.wind.datasetTableWidget.setItem(i, 2, citem)
        else:
            self.wind.datasetTableWidget.clear()


    def select_datasets_by_geometry(self):
        selected_features_ids_list = None
        if self.mode == 'proc':
            if self.selectedProcLayer != None and len(self.selectedProcFeaturesList) > 0:
                if 'proc_id' in [f.name() for f in self.selectedProcLayer.fields()]:
                    if 'pol_id' in [f.name() for f in self.selectedProcLayer.fields()]:
                        selected_features_ids_list = list(set([f.attribute('pol_id') for f in self.selectedProcFeaturesList]))
                    elif 'line_id' in [f.name() for f in self.selectedProcLayer.fields()]:
                        selected_features_ids_list = list(set([f.attribute('line_id') for f in self.selectedProcFeaturesList]))
                    else:
                        selected_features_ids_list = []
        elif self.mode == 'field':
            if self.selectedFieldLayer and self.selectedFieldFeaturesList:
                if 'survey_id' in [f.name() for f in self.selectedFieldLayer.fields()]:
                    if 'pol_id' in [f.name() for f in self.selectedFieldLayer.fields()]:
                        selected_features_ids_list = list(set([f.attribute('pol_id') for f in self.selectedFieldFeaturesList]))
                    elif 'field_line_id' in [f.name() for f in self.selectedFieldLayer.fields()]:
                        selected_features_ids_list = list(set([f.attribute('field_line_id') for f in self.selectedFieldFeaturesList]))
                    else:
                        selected_features_ids_list = []
        if self.datasets_to_geometries_list and self.seismic_datasets_view_list and selected_features_ids_list:
            selected_features_dataset_ids = [y['dataset_id'] for y in self.datasets_to_geometries_list if y['geometry_id'] in selected_features_ids_list]
            [x.setSelected(False) for x in self.wind.datasetTableWidget.selectedItems()]
            self.wind.datasetTableWidget.clear()
            self.wind.datasetTableWidget.setRowCount(0)
            self.wind.datasetTableWidget.setColumnCount(3)
            self.wind.datasetTableWidget.setHorizontalHeaderLabels(['Название', 'Тип', 'формат'])
            header = self.wind.datasetTableWidget.horizontalHeader()
            header.resizeSection(0, 100)
            header.resizeSection(1, 200)
            header.resizeSection(2, 50)
            if selected_features_dataset_ids:
                self.dataset_id_filter = selected_features_dataset_ids
            else:
                self.dataset_id_filter = [-1]
            self.refresh_datasets()
            self.dataset_id_filter = None
        else:
            self.iface.messageBar().pushMessage('Ошибка', f"Нужно выбрать Проект по обработке, содержащий наборы данных",
                                                level=Qgis.Warning,
                                                duration=5)
        # else:
        #     self.iface.messageBar().pushMessage('Ошибка', f"Нужно выбрать слой и объекты в нем", level=Qgis.Warning,
        #                                         duration=5)


    def select_geometry_by_datasets(self):
        if self.mode == 'proc':
            geom_layer = self.selectedProcLayer
            line_id_fname = 'line_id'
            pol_id_fname = 'pol_id'
            message1 = f"Нужно выбрать наборы данных и слой с геометрией обработанной сейсмики"
            message2 = f"Нужно выбрать Обработку, содержащую наборы данных"
        elif self.mode == 'field':
            geom_layer = self.selectedFieldLayer
            line_id_fname = 'field_line_id'
            pol_id_fname = 'pol_id'
            message1 = f"Нужно выбрать наборы данных и слой с геометрией полевой сейсмики"
            message2 = f"Нужно выбрать Съемку, содержащую наборы данных"
        else:
            geom_layer = None
            line_id_fname = None
            pol_id_fname = None
            message1 = None
            message2 = None
        if self.datasets_to_geometries_list and self.seismic_datasets_view_list:
            selected_dataset_rows = list(set([x.row() for x in self.wind.datasetTableWidget.selectedItems()]))
            selected_dataset_ids = [self.seismic_datasets_view_list[i]['dataset_id'] for i in selected_dataset_rows]
            if selected_dataset_ids and geom_layer and \
                any([line_id_fname in [f.name() for f in geom_layer.fields()],
                     pol_id_fname in [f.name() for f in geom_layer.fields()]]):
                geom_string = ', '.join([str(x['geometry_id']) for x in self.datasets_to_geometries_list if x['dataset_id'] in selected_dataset_ids])
                geom_layer.removeSelection()
                if line_id_fname in [f.name() for f in geom_layer.fields()]:
                    gfield = line_id_fname
                else:
                    gfield = pol_id_fname
                query = f'"{gfield}" in ({geom_string})'
                geom_layer.selectByExpression(query)
                if geom_layer.selectedFeatures():
                    project_crs = QgsCoordinateReferenceSystem(QgsProject.instance().crs())
                    layer_crs = geom_layer.crs()
                    lyr2proj = QgsCoordinateTransform(layer_crs, project_crs, QgsProject.instance())
                    box = lyr2proj.transformBoundingBox(geom_layer.boundingBoxOfSelected())
                    self.iface.mapCanvas().setExtent(box)
                    self.iface.mapCanvas().refresh()
            else:
                self.iface.messageBar().pushMessage('Ошибка', message1, level=Qgis.Warning, duration=5)
        else:
            self.iface.messageBar().pushMessage('Ошибка', message2, level=Qgis.Warning, duration=5)


    def link_selected_datasets_to_geometry(self):
        if self.mode == 'proc':
            geom_layer = self.selectedProcLayer
            selected_features_list = self.selectedProcFeaturesList
            table_2d = self.seismic_lines_processed_2d
            table_3d = self.seismic_pols_processed_3d
            line_id_fname = 'line_id'
            pol_id_fname = 'pol_id'
            message1 = 'Нужно выбрать хотя бы один Набор данных'
            message2 = f"Нужно выбрать хотя бы одну Обработку и хотя бы один Набор данных"
        elif self.mode == 'field':
            geom_layer = self.selectedFieldLayer
            selected_features_list = self.selectedFieldFeaturesList
            table_2d = self.seismic_lines_field_2d
            table_3d = self.seismic_pols_field_3d
            line_id_fname = 'field_line_id'
            pol_id_fname = 'pol_id'
            message1 = 'Нужно выбрать хотя бы один Набор данных'
            message2 = f"Нужно выбрать хотя бы одну Съемку и хотя бы один Набор данных"
        else:
            geom_layer = None
            selected_features_list = None
            table_2d = None
            table_3d = None
            line_id_fname = None
            pol_id_fname = None
            message1 = None
            message2 = None
        if self.datasets_to_geometries_list and self.seismic_datasets_view_list:
            selected_cells = self.wind.datasetTableWidget.selectedItems()
            selected_rows = list(set([x.row() for x in selected_cells]))
            if selected_rows:
                dataset_ids = [self.seismic_datasets_view_list[i]['dataset_id'] for i in selected_rows]
                if geom_layer and selected_features_list and \
                        any([line_id_fname in[f.name() for f in geom_layer.fields()],
                             pol_id_fname in[f.name() for f in geom_layer.fields()]]):
                    if line_id_fname in [f.name() for f in geom_layer.fields()]:
                        gfield = line_id_fname
                        table = table_2d
                    else:
                        gfield = pol_id_fname
                        table = table_3d
                    geom_ids = [x[gfield] for x in selected_features_list]
                    sql = f"insert into {self.datasets_to_geometries}(dataset_id, geometry_id) values"
                    values_to_insert = []
                    for geom_id in geom_ids:
                        for dataset_id in dataset_ids:
                            values_to_insert.append(f"({str(dataset_id)}, {str(geom_id)})")
                    sql += ', '.join(values_to_insert)
                    self.sql = sql
                    mwidget = self.iface.messageBar().createMessage(
                        f"Связать {str(len(dataset_ids))} наборов данных с {str(len(geom_ids))} объектами в активном слое?")
                    mbutton = QPushButton(mwidget)
                    mbutton.setText('Подтвердить')
                    mbutton.pressed.connect(self.execute_sql)
                    mwidget.layout().addWidget(mbutton)
                    self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=5)
            else:
                self.iface.messageBar().pushMessage('Ошибка', message1, level=Qgis.Warning, duration=3)
        else:
            self.iface.messageBar().pushMessage('Ошибка', message2, level=Qgis.Warning, duration=5)


    def unlink_selected_datasets_from_geometry(self):
        if self.mode == 'proc':
            geom_layer = self.selectedProcLayer
            selected_features_list = self.selectedProcFeaturesList
            table_2d = self.seismic_lines_processed_2d
            table_3d = self.seismic_pols_processed_3d
            line_id_fname = 'line_id'
            pol_id_fname = 'pol_id'
        elif self.mode == 'field':
            geom_layer = self.selectedFieldLayer
            selected_features_list = self.selectedFieldFeaturesList
            table_2d = self.seismic_lines_field_2d
            table_3d = self.seismic_pols_field_3d
            line_id_fname = 'field_line_id'
            pol_id_fname = 'pol_id'
        else:
            geom_layer = None
            selected_features_list = None
            table_2d = None
            table_3d = None
            line_id_fname = None
            pol_id_fname = None
        selected_cells = self.wind.datasetTableWidget.selectedItems()
        selected_rows = list(set([x.row() for x in selected_cells]))
        if selected_rows:
            dataset_ids = [self.seismic_datasets_view_list[i]['dataset_id'] for i in selected_rows]
            if geom_layer and selected_features_list and \
                any([line_id_fname in [f.name() for f in geom_layer.fields()],
                     pol_id_fname in [f.name() for f in geom_layer.fields()]]):
                if line_id_fname in [f.name() for f in geom_layer.fields()]:
                    gfield = line_id_fname
                    table = table_2d
                else:
                    gfield = pol_id_fname
                    table = table_3d
                geom_ids = [x[gfield] for x in selected_features_list]
                sql = f"delete from {self.datasets_to_geometries} where "
                values_to_delete = []
                for geom_id in geom_ids:
                    for dataset_id in dataset_ids:
                        values_to_delete.append(f"(geometry_id = {str(geom_id)} and dataset_id = {str(dataset_id)})")
                sql += ' or '.join(values_to_delete)
                self.sql = sql
                mwidget = self.iface.messageBar().createMessage(
                    f"Удалить связь {str(len(dataset_ids))} наборов данных и {str(len(geom_ids))} объектов в активном слое?")
                mbutton = QPushButton(mwidget)
                mbutton.setText('Подтвердить')
                mbutton.pressed.connect(self.execute_sql)
                mwidget.layout().addWidget(mbutton)
                self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=5)
            else:
                self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать хотя бы одну геометрию',
                                                    level=Qgis.Warning,
                                                    duration=3)
        else:
            self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать хотя бы один набор данных', level=Qgis.Warning,
                                                duration=3)


    def check_show_datasets_for_all_proc(self):
        self.show_datasets_for_selected_proc = False
        self.refresh_datasets()

    def check_show_datasets_for_selected_proc(self):
        self.show_datasets_for_selected_proc = True
        self.refresh_datasets()

    def check_show_datasets_for_all_surveys(self):
        self.show_datasets_for_selected_surveys = False
        self.refresh_datasets()

    def check_show_datasets_for_selected_surveys(self):
        self.show_datasets_for_selected_surveys = True
        self.refresh_datasets()


    def add_dataset(self):
        self.adddatasetdlg = AddDatasetDialog()
        self.adddatasetdlg.datasetRefreshLinksButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.adddatasetdlg.datasetRefreshDrivesButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.adddatasetdlg.datasetRefreshTransmittalsButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))

        if self.mode == 'proc':
            geom_layer = self.selectedProcLayer
            selected_features_list = self.selectedProcFeaturesList
            table_2d = self.seismic_lines_processed_2d
            table_3d = self.seismic_pols_processed_3d
            line_id_fname = 'line_id'
            pol_id_fname = 'pol_id'
            message1 = 'Нужно указать все обязательные поля и выбрать геометрию обработанной сейсмики'
            message2 = 'Нужно выбрать слой и геометрию обработанной сейсмики'
        elif self.mode == 'field':
            geom_layer = self.selectedFieldLayer
            selected_features_list = self.selectedFieldFeaturesList
            table_2d = self.seismic_lines_field_2d
            table_3d = self.seismic_pols_field_3d
            line_id_fname = 'field_line_id'
            pol_id_fname = 'pol_id'
            message1 = 'Нужно указать все обязательные поля и выбрать геометрию полевой сейсмики'
            message2 = 'Нужно выбрать слой и геометрию полевой сейсмики'
        else:
            geom_layer = None
            selected_features_list = None
            table_2d = None
            table_3d = None
            line_id_fname = None
            pol_id_fname = None
            message1 = None
            message2 = None
            
        self.adddatasetdlg.new_dataset_id = None
        self.adddatasetdlg.datasource_types_list = None
        self.adddatasetdlg.drives_view_list = None
        self.adddatasetdlg.links_list = None
        self.adddatasetdlg.transmittals_list = None

        self.adddatasetdlg.drives_to_link = []
        self.adddatasetdlg.links_to_link = []
        self.adddatasetdlg.transmittals_to_link = []


        def reload_datasource_types():
            self.adddatasetdlg.datasetDataSourceTypeComboBoxInput.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.datasource_types}"
                    cur.execute(sql)
                    self.adddatasetdlg.datasource_types_list = cur.fetchall()
                    self.adddatasetdlg.datasetDataSourceTypeComboBoxInput.addItems([row['name'] for row in self.adddatasetdlg.datasource_types_list])

        def reload_seismic_types():
            self.adddatasetdlg.datasetTypeComboBoxInput.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.seismic_types}"
                    cur.execute(sql)
                    self.adddatasetdlg.seismic_types_list = cur.fetchall()
                    self.adddatasetdlg.datasetTypeComboBoxInput.addItems(
                        [row['name'] for row in self.adddatasetdlg.seismic_types_list])

        def reload_formats():
            self.adddatasetdlg.datasetFormatComboBoxInput.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.formats}"
                    cur.execute(sql)
                    self.adddatasetdlg.formats_list = cur.fetchall()
                    self.adddatasetdlg.datasetFormatComboBoxInput.addItems(
                        [row['name'] for row in self.adddatasetdlg.formats_list])

        def reload_data_quality():
            self.adddatasetdlg.datasetQualityComboBoxInput.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.data_quality} order by quality_range DESC"
                    cur.execute(sql)
                    self.adddatasetdlg.data_quality_list = cur.fetchall()
                    self.adddatasetdlg.datasetQualityComboBoxInput.addItem('Выберите качество')
                    self.adddatasetdlg.datasetQualityComboBoxInput.addItems(
                        [row['name_ru'] for row in self.adddatasetdlg.data_quality_list])

        def get_drives_from_postgres():
            sql = f"select * from {self.drives_view}"
            filter_str = self.adddatasetdlg.datasetAllDrivesFilterLineEditInput.text().lower().strip()
            if filter_str:
                sql += f" where (LOWER(drive_number) like '%{filter_str}%' or LOWER(drive_type) like '%{filter_str}%' " \
                       f"or LOWER(label) like '%{filter_str}%' or LOWER(conf_name) like '%{filter_str}%' " \
                       f"or LOWER(conf_name_short) like '%{filter_str}%' or LOWER(conf_limit) like '%{filter_str}%')"
            sql += ' order by drive_number'
            try:
                with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                    if pgconn:
                        with pgconn.cursor() as cur:
                            cur.execute(sql)
                            self.adddatasetdlg.drives_view_list = cur.fetchall()
                            return True
                    else:
                        self.iface.messageBar().pushMessage('Ошибка', 'Не удалось загрузить данные о физических носителях из базы',
                                                level=Qgis.Critical, duration=5)
                        return False
            except:
                self.iface.messageBar().pushMessage('Ошибка', 'Не удалось загрузить данные о физических носителях из базы ' + sql,
                                                    level=Qgis.Critical, duration=5)
                return False

        def reload_drives():
            self.adddatasetdlg.datasetAllDrivesTableWidget.clear()
            self.adddatasetdlg.datasetAllDrivesTableWidget.setRowCount(0)
            self.adddatasetdlg.datasetAllDrivesTableWidget.setColumnCount(2)
            self.adddatasetdlg.datasetAllDrivesTableWidget.setHorizontalHeaderLabels(['Номер', 'Тип'])
            header = self.adddatasetdlg.datasetAllDrivesTableWidget.horizontalHeader()
            header.resizeSection(0, 148)
            header.resizeSection(1, 50)
            if get_drives_from_postgres():
                for i, drive_row in enumerate(self.adddatasetdlg.drives_view_list):
                    self.adddatasetdlg.datasetAllDrivesTableWidget.insertRow(i)
                    citem = QTableWidgetItem(drive_row['drive_number'])
                    # print(drive_row['drive_number'])
                    citem.setToolTip(str(drive_row['drive_number']))
                    citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.adddatasetdlg.datasetAllDrivesTableWidget.setItem(i, 0, citem)
                    citem = QTableWidgetItem(drive_row['drive_type'])
                    citem.setToolTip(str(drive_row['drive_type']))
                    citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.adddatasetdlg.datasetAllDrivesTableWidget.setItem(i, 1, citem)

        def reload_links():
            filter_string = self.adddatasetdlg.datasetLinksFilterLineEditInput.text().strip().lower().replace("'", "''").replace('\\', '\\\\')
            self.adddatasetdlg.datasetLinkComboBoxInput.clear()
            sql = f"select * from {self.links}"
            if filter_string:
                sql += f" where LOWER(link) like'%{filter_string}%'"
            sql += " order by link"
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    cur.execute(sql)
                    self.adddatasetdlg.links_list = list(cur.fetchall())
                    self.adddatasetdlg.datasetLinkComboBoxInput.addItem('Выберите ссылку')
                    self.adddatasetdlg.datasetLinkComboBoxInput.addItems([row['link'] for row in self.adddatasetdlg.links_list])

        def reload_transmittals():
            filter_string = self.adddatasetdlg.datasetTransmittalsFilterLineEditInput.text().strip().lower().replace("'", "''")
            self.adddatasetdlg.datasetTransmittalComboBoxInput.clear()
            sql = f"select * from {self.transmittals_view}"
            if filter_string:
                sql += f" where LOWER(transmittal_type) like'%{filter_string}%'" \
                       f" or LOWER(number) like'%{filter_string}%'" \
                       f" or LOWER(name) like'%{filter_string}%'" \
                       f" or LOWER(from_company) like'%{filter_string}%'" \
                       f" or LOWER(to_company) like'%{filter_string}%'" \
                       f" or datestamp::text like'%{filter_string}%'" \
                       f" or LOWER(comments) like'%{filter_string}%'" \
                       f" or LOWER(from_company_short) like'%{filter_string}%'" \
                       f" or LOWER(to_company_short) like'%{filter_string}%'"
            sql += ' order by number'
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    cur.execute(sql)
                    self.adddatasetdlg.transmittals_list = list(cur.fetchall())
                    self.adddatasetdlg.datasetTransmittalComboBoxInput.addItem('Выберите акт приема-передачи')
                    for row in self.adddatasetdlg.transmittals_list:
                        transm_item_str = ''
                        if row['number']:
                            transm_item_str += f"{row['number']} "
                        if row['datestamp']:
                            transm_item_str += f"от {row['datestamp']} "
                        if row['from_company_short']:
                            transm_item_str += f" {row['from_company_short']}"
                        if row['to_company_short']:
                            transm_item_str += f"->{row['to_company_short']}"
                        self.adddatasetdlg.datasetTransmittalComboBoxInput.addItem(transm_item_str)

        reload_datasource_types()
        reload_seismic_types()
        reload_formats()
        reload_data_quality()
        reload_drives()
        reload_links()
        reload_transmittals()

        def reload_linked_drives():
            self.adddatasetdlg.datasetLinkedDrivesTableWidget.clear()
            self.adddatasetdlg.datasetLinkedDrivesTableWidget.setRowCount(0)
            self.adddatasetdlg.datasetLinkedDrivesTableWidget.setColumnCount(2)
            self.adddatasetdlg.datasetLinkedDrivesTableWidget.setHorizontalHeaderLabels(['Номер', 'Тип'])
            header = self.adddatasetdlg.datasetLinkedDrivesTableWidget.horizontalHeader()
            header.resizeSection(0, 130)
            header.resizeSection(1, 50)
            if self.adddatasetdlg.drives_to_link:
                for i, drive_row in enumerate(self.adddatasetdlg.drives_to_link):
                    self.adddatasetdlg.datasetLinkedDrivesTableWidget.insertRow(i)
                    citem = QTableWidgetItem(drive_row['drive_number'])
                    # print(drive_row['drive_number'])
                    citem.setToolTip(str(drive_row['drive_number']))
                    citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.adddatasetdlg.datasetLinkedDrivesTableWidget.setItem(i, 0, citem)
                    citem = QTableWidgetItem(drive_row['drive_type'])
                    citem.setToolTip(str(drive_row['drive_type']))
                    citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.adddatasetdlg.datasetLinkedDrivesTableWidget.setItem(i, 1, citem)

        def link_drive():
            selected_drive_rows = list(set([x.row() for x in self.adddatasetdlg.datasetAllDrivesTableWidget.selectedItems()]))
            if selected_drive_rows:
                self.adddatasetdlg.drives_to_link.extend([self.adddatasetdlg.drives_view_list[x] for x in selected_drive_rows if self.adddatasetdlg.drives_view_list[x] not in self.adddatasetdlg.drives_to_link])
                reload_linked_drives()
            else:
                self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать хотя бы один носитель', level=Qgis.Warning, duration=5)

        def unlink_drive():
            selected_drive_rows = list(set([x.row() for x in self.adddatasetdlg.datasetLinkedDrivesTableWidget.selectedItems()]))
            if selected_drive_rows:
                # [self.adddatasetdlg.drives_to_link.pop(x) for x in selected_drive_rows]
                self.adddatasetdlg.drives_to_link = [x for x in self.adddatasetdlg.drives_to_link if self.adddatasetdlg.drives_to_link.index(x) not in selected_drive_rows]
                reload_linked_drives()
            else:
                self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать хотя бы один связанный носитель', level=Qgis.Warning,
                                                    duration=5)

        def reload_linked_links():
            self.adddatasetdlg.datasetLinksTableWidget.clear()
            self.adddatasetdlg.datasetLinksTableWidget.setRowCount(0)
            self.adddatasetdlg.datasetLinksTableWidget.setColumnCount(2)
            self.adddatasetdlg.datasetLinksTableWidget.setHorizontalHeaderLabels(['Адрес', 'id'])
            header = self.adddatasetdlg.datasetLinksTableWidget.horizontalHeader()
            header.resizeSection(0, 1000)
            header.resizeSection(1, 10)
            if self.adddatasetdlg.links_to_link:
                for i, link_row in enumerate(self.adddatasetdlg.links_to_link):
                    self.adddatasetdlg.datasetLinksTableWidget.insertRow(i)
                    citem = QTableWidgetItem(link_row['link'])
                    citem.setToolTip(str(link_row['link']))
                    citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.adddatasetdlg.datasetLinksTableWidget.setItem(i, 0, citem)
                    citem = QTableWidgetItem(link_row['link_id'])
                    citem.setToolTip(str(link_row['link_id']))
                    citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.adddatasetdlg.datasetLinksTableWidget.setItem(i, 1, citem)

        def link_link():
            selected_link_index = self.adddatasetdlg.datasetLinkComboBoxInput.currentIndex() - 1
            if selected_link_index >= 0:
                if self.adddatasetdlg.links_list[selected_link_index] not in self.adddatasetdlg.links_to_link:
                    self.adddatasetdlg.links_to_link.append(self.adddatasetdlg.links_list[selected_link_index])
                reload_linked_links()
                self.adddatasetdlg.datasetLinkComboBoxInput.setCurrentIndex(0)

        def unlink_link():
            selected_link_rows = list(set([x.row() for x in self.adddatasetdlg.datasetLinksTableWidget.selectedItems()]))
            if selected_link_rows:
                self.adddatasetdlg.links_to_link = [x for x in self.adddatasetdlg.links_to_link if self.adddatasetdlg.links_to_link.index(x) not in selected_link_rows]
                reload_linked_links()

            else:
                self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать хотя бы одну связанную ссылку', level=Qgis.Warning,
                                                    duration=5)

        def reload_linked_transmittals():
            self.adddatasetdlg.datasetTransmittalsTableWidget.clear()
            self.adddatasetdlg.datasetTransmittalsTableWidget.setRowCount(0)
            self.adddatasetdlg.datasetTransmittalsTableWidget.setColumnCount(4)
            self.adddatasetdlg.datasetTransmittalsTableWidget.setHorizontalHeaderLabels(['Номер', 'Дата', 'Отправитель', 'Получатель'])
            header = self.adddatasetdlg.datasetTransmittalsTableWidget.horizontalHeader()
            header.resizeSection(0, 70)
            header.resizeSection(1, 70)
            header.resizeSection(2, 100)
            header.resizeSection(3, 100)
            if self.adddatasetdlg.transmittals_to_link:
                for i, transmittal_row in enumerate(self.adddatasetdlg.transmittals_to_link):
                    self.adddatasetdlg.datasetTransmittalsTableWidget.insertRow(i)
                    citem = QTableWidgetItem(transmittal_row['number'])
                    citem.setToolTip(str(transmittal_row['number']))
                    citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.adddatasetdlg.datasetTransmittalsTableWidget.setItem(i, 0, citem)
                    citem = QTableWidgetItem(str(transmittal_row['datestamp']))
                    citem.setToolTip(str(transmittal_row['datestamp']))
                    citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.adddatasetdlg.datasetTransmittalsTableWidget.setItem(i, 1, citem)
                    citem = QTableWidgetItem(str(transmittal_row['from_company_short']))
                    citem.setToolTip(str(transmittal_row['from_company']))
                    citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.adddatasetdlg.datasetTransmittalsTableWidget.setItem(i, 2, citem)
                    citem = QTableWidgetItem(str(transmittal_row['to_company_short']))
                    citem.setToolTip(str(transmittal_row['to_company']))
                    citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.adddatasetdlg.datasetTransmittalsTableWidget.setItem(i, 3, citem)

        def link_transmittal():
            selected_transmittal_index = self.adddatasetdlg.datasetTransmittalComboBoxInput.currentIndex() - 1
            if selected_transmittal_index >= 0:
                if self.adddatasetdlg.transmittals_list[selected_transmittal_index] not in self.adddatasetdlg.transmittals_to_link:
                    self.adddatasetdlg.transmittals_to_link.append(self.adddatasetdlg.transmittals_list[selected_transmittal_index])
                reload_linked_transmittals()
                self.adddatasetdlg.datasetTransmittalComboBoxInput.setCurrentIndex(0)

        def unlink_transmittal():
            selected_transmittal_rows = list(set([x.row() for x in self.adddatasetdlg.datasetTransmittalsTableWidget.selectedItems()]))
            if selected_transmittal_rows:
                self.adddatasetdlg.transmittals_to_link = [x for x in self.adddatasetdlg.transmittals_to_link if self.adddatasetdlg.transmittals_to_link.index(x) not in selected_transmittal_rows]
                reload_linked_transmittals()
            else:
                self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать хотя бы один связанный акт приема-передачи', level=Qgis.Warning,
                                                    duration=5)

        def refresh_datasets_and_select_new():
            self.wind.showAllProcDatasetsRadioButton.setChecked(True)
            self.check_show_datasets_for_all_proc()
            new_dataset_row = self.seismic_datasets_view_list.index([x for x in self.seismic_datasets_view_list if x['dataset_id'] == self.adddatasetdlg.new_dataset_id][0])
            self.wind.datasetTableWidget.selectRow(new_dataset_row)

        def generate_and_execute_sql():
            drive_ids_to_insert = None
            link_ids_to_insert = None
            transmittal_ids_to_insert = None

            selected_datasource_type_index = self.adddatasetdlg.datasetDataSourceTypeComboBoxInput.currentIndex()
            new_shortname = self.adddatasetdlg.datasetShortnameLineEditInput.text().strip().replace("'", "''")
            new_name = self.adddatasetdlg.datasetNameLineEditInput.text().strip().replace("'", "''")
            selected_type_index = self.adddatasetdlg.datasetTypeComboBoxInput.currentIndex()
            selected_format_index = self.adddatasetdlg.datasetFormatComboBoxInput.currentIndex()
            selected_quality_index = self.adddatasetdlg.datasetQualityComboBoxInput.currentIndex() - 1
            new_sizegb = self.adddatasetdlg.datasetSizeGbSpinBoxInput.value()
            if all([new_shortname, new_name, selected_features_list]):
                selected_datasource_type_id = self.adddatasetdlg.datasource_types_list[selected_datasource_type_index]['datasource_type_id']
                selected_type_id = self.adddatasetdlg.seismic_types_list[selected_type_index]['seismic_type_id']
                selected_format_id = self.adddatasetdlg.formats_list[selected_format_index]['format_id']
                selected_quality_id = None
                if selected_quality_index >= 0:
                    selected_quality_id = self.adddatasetdlg.data_quality_list[selected_quality_index]['data_quality_id']
                if self.adddatasetdlg.drives_to_link:
                    drive_ids_to_insert = [x['drive_id'] for x in self.adddatasetdlg.drives_to_link]
                if self.adddatasetdlg.links_to_link:
                    link_ids_to_insert = [x['link_id'] for x in self.adddatasetdlg.links_to_link]
                if self.adddatasetdlg.transmittals_to_link:
                    transmittal_ids_to_insert = [x['transmittal_id'] for x in self.adddatasetdlg.transmittals_to_link]
                if any(['proc_id' in [f.name() for f in geom_layer.fields()], 'survey_id' in [f.name() for f in geom_layer.fields()]]):


                    geom_field = ''
                    if pol_id_fname in [f.name() for f in geom_layer.fields()]:
                        geom_field = pol_id_fname
                    elif line_id_fname in [f.name() for f in geom_layer.fields()]:
                        geom_field = line_id_fname
                    geom_ids_to_link = [f.attribute(geom_field) for f in selected_features_list]
                else:
                    geom_ids_to_link = None
                with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                    with pgconn.cursor() as cur:
                        sql = f"select * from nextval('{self.seismic_datasets_dataset_id_seq}'::regclass)"
                        cur.execute(sql)
                        self.adddatasetdlg.new_dataset_id = cur.fetchall()[0][0]
                fields_to_update = ['dataset_id', 'datasource_type_id', 'shortname', 'name', 'seismic_type_id', 'format_id']
                values_to_insert = [str(self.adddatasetdlg.new_dataset_id), str(selected_datasource_type_id), f"'{new_shortname}'", f"'{new_name}'", str(selected_type_id), str(selected_format_id)]
                if selected_quality_id:
                    fields_to_update.append('data_quality_id')
                    values_to_insert.append(str(selected_quality_id))
                if new_sizegb > 0:
                    fields_to_update.append('size_gb')
                    values_to_insert.append(str(new_sizegb))
                sql = f"insert into {self.seismic_datasets}({', '.join(fields_to_update)}) values({', '.join(values_to_insert)});"
                if drive_ids_to_insert:
                    sql += f" insert into {self.drives_to_datasets}(drive_id, dataset_id) " \
                           f"values{', '.join(['(' + str(x) + ', ' + str(self.adddatasetdlg.new_dataset_id) + ')' for x in drive_ids_to_insert])}" \
                           f";"
                if link_ids_to_insert:
                    sql += f" insert into {self.links_to_datasets}(link_id, dataset_id) " \
                           f"values{', '.join(['(' + str(x) + ', ' + str(self.adddatasetdlg.new_dataset_id) + ')' for x in link_ids_to_insert])}" \
                           f";"
                if transmittal_ids_to_insert:
                    sql += f" insert into {self.seismic_datasets_to_transmittals}(transmittal_id, seismic_dataset_id) " \
                           f"values{', '.join(['(' + str(x) + ', ' + str(self.adddatasetdlg.new_dataset_id) + ')' for x in transmittal_ids_to_insert])}" \
                           f";"
                if geom_ids_to_link:
                    sql += f" insert into {self.datasets_to_geometries}(geometry_id, dataset_id) " \
                           f"values{', '.join(['(' + str(x) + ', ' + str(self.adddatasetdlg.new_dataset_id) + ')' for x in geom_ids_to_link])}" \
                           f";"
                # self.iface.messageBar().pushMessage('sql',
                #                                     sql,
                #                                     level=Qgis.Success,
                #                                     duration=5)
                self.sql = sql
                mwidget = self.iface.messageBar().createMessage(f"Добавить в базу набор данных {str(new_name)}?")
                mbutton = QPushButton(mwidget)
                mbutton.setText('Подтвердить')
                mbutton.pressed.connect(self.execute_sql)
                # mbutton.pressed.connect(refresh_datasets_and_select_new)
                mwidget.layout().addWidget(mbutton)
                self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=5)
                self.adddatasetdlg.accept()
            else:
                self.iface.messageBar().pushMessage('Ошибка', message1, level=Qgis.Warning, duration=5)

        self.adddatasetdlg.datasetRefreshDrivesButton.clicked.connect(reload_drives)
        self.adddatasetdlg.datasetAllDrivesFilterLineEditInput.textEdited.connect(reload_drives)
        self.adddatasetdlg.datasetNewDriveButton.clicked.connect(self.add_drive)
        self.adddatasetdlg.datasetLinkDriveButton.clicked.connect(link_drive)
        self.adddatasetdlg.datasetUnLinkDriveButton.clicked.connect(unlink_drive)
        self.adddatasetdlg.datasetRefreshLinksButton.clicked.connect(reload_links)
        self.adddatasetdlg.datasetLinksFilterLineEditInput.textEdited.connect(reload_links)
        self.adddatasetdlg.datasetLinkComboBoxInput.activated.connect(link_link)
        self.adddatasetdlg.unlinkSelectedLinksButton.clicked.connect(unlink_link)
        self.adddatasetdlg.datasetNewLinkButton.clicked.connect(self.add_link)
        self.adddatasetdlg.datasetRefreshTransmittalsButton.clicked.connect(reload_transmittals)
        self.adddatasetdlg.datasetTransmittalsFilterLineEditInput.textEdited.connect(reload_transmittals)
        self.adddatasetdlg.datasetTransmittalComboBoxInput.activated.connect(link_transmittal)
        self.adddatasetdlg.unlinkSelectedTransmittalsButton.clicked.connect(unlink_transmittal)
        self.adddatasetdlg.datasetNewTransmittalButton.clicked.connect(self.add_transmittal)
        self.adddatasetdlg.insertDatasetButton.clicked.connect(generate_and_execute_sql)

        if selected_features_list:
            self.adddatasetdlg.show()
        else:
            self.iface.messageBar().pushMessage('Ошибка', message2, level=Qgis.Warning, duration=5)


    def update_dataset(self):
        selected_dataset_rows = list(set([x.row() for x in self.wind.datasetTableWidget.selectedItems()]))
        if len(selected_dataset_rows) == 1:
            self.updatedatasetdlg = AddDatasetDialog()
            self.updatedatasetdlg.datasetRefreshLinksButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
            self.updatedatasetdlg.datasetRefreshDrivesButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
            self.updatedatasetdlg.datasetRefreshTransmittalsButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))

            if self.mode == 'proc':
                geom_layer = self.selectedProcLayer
                selected_features_list = self.selectedProcFeaturesList
                table_2d = self.seismic_lines_processed_2d
                table_3d = self.seismic_pols_processed_3d
                line_id_fname = 'line_id'
                pol_id_fname = 'pol_id'
            elif self.mode == 'field':
                geom_layer = self.selectedFieldLayer
                selected_features_list = self.selectedFieldFeaturesList
                table_2d = self.seismic_lines_field_2d
                table_3d = self.seismic_pols_field_3d
                line_id_fname = 'field_line_id'
                pol_id_fname = 'pol_id'
            else:
                geom_layer = None
                selected_features_list = None
                table_2d = None
                table_3d = None
                line_id_fname = None
                pol_id_fname = None
            
            self.updatedatasetdlg.new_dataset_id = None
            self.updatedatasetdlg.datasource_types_list = None
            self.updatedatasetdlg.drives_view_list = None
            self.updatedatasetdlg.links_list = None
            self.updatedatasetdlg.transmittals_list = None

            self.updatedatasetdlg.drives_to_link = []
            self.updatedatasetdlg.links_to_link = []
            self.updatedatasetdlg.transmittals_to_link = []

            self.updatedatasetdlg.selected_dataset_row =  selected_dataset_rows[0]
            self.updatedatasetdlg.setWindowTitle('Изменить набор данных')
            self.updatedatasetdlg.insertDatasetButton.setText('Изменить набор данных')

            def reload_datasource_types():
                self.updatedatasetdlg.datasetDataSourceTypeComboBoxInput.clear()
                with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                    with pgconn.cursor() as cur:
                        sql = f"select * from {self.datasource_types}"
                        cur.execute(sql)
                        self.updatedatasetdlg.datasource_types_list = cur.fetchall()
                        self.updatedatasetdlg.datasetDataSourceTypeComboBoxInput.addItems([row['name'] for row in self.updatedatasetdlg.datasource_types_list])
                    selected_datasource_type = self.seismic_datasets_view_list[self.updatedatasetdlg.selected_dataset_row]['datasource_type']
                if selected_datasource_type:
                    self.updatedatasetdlg.datasetDataSourceTypeComboBoxInput.setCurrentText(selected_datasource_type)

            def reload_dataset_shortname():
                self.updatedatasetdlg.datasetShortnameLineEditInput.clear()
                self.updatedatasetdlg.datasetShortnameLineEditInput.setText(self.seismic_datasets_view_list[self.updatedatasetdlg.selected_dataset_row]['shortname'])
            
            def reload_dataset_name():
                self.updatedatasetdlg.datasetNameLineEditInput.clear()
                self.updatedatasetdlg.datasetNameLineEditInput.setText(self.seismic_datasets_view_list[self.updatedatasetdlg.selected_dataset_row]['name'])

            def reload_seismic_types():
                self.updatedatasetdlg.datasetTypeComboBoxInput.clear()
                with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                    with pgconn.cursor() as cur:
                        sql = f"select * from {self.seismic_types}"
                        cur.execute(sql)
                        self.updatedatasetdlg.seismic_types_list = cur.fetchall()
                        self.updatedatasetdlg.datasetTypeComboBoxInput.addItems([row['name'] for row in self.updatedatasetdlg.seismic_types_list])
                    selected_seismic_type = self.seismic_datasets_view_list[self.updatedatasetdlg.selected_dataset_row]['seismic_type']
                if selected_seismic_type:
                    self.updatedatasetdlg.datasetTypeComboBoxInput.setCurrentText(selected_seismic_type)

            def reload_formats():
                self.updatedatasetdlg.datasetFormatComboBoxInput.clear()
                with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                    with pgconn.cursor() as cur:
                        sql = f"select * from {self.formats}"
                        cur.execute(sql)
                        self.updatedatasetdlg.formats_list = cur.fetchall()
                        self.updatedatasetdlg.datasetFormatComboBoxInput.addItems([row['name'] for row in self.updatedatasetdlg.formats_list])
                    selected_format = self.seismic_datasets_view_list[self.updatedatasetdlg.selected_dataset_row]['format']
                if selected_format:
                    self.updatedatasetdlg.datasetFormatComboBoxInput.setCurrentText(selected_format)

            def reload_data_quality():
                self.updatedatasetdlg.datasetQualityComboBoxInput.clear()
                with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                    with pgconn.cursor() as cur:
                        sql = f"select * from {self.data_quality} order by quality_range DESC"
                        cur.execute(sql)
                        self.updatedatasetdlg.data_quality_list = cur.fetchall()
                        self.updatedatasetdlg.datasetQualityComboBoxInput.addItem('--Выбрать--')
                        self.updatedatasetdlg.datasetQualityComboBoxInput.addItems(
                            [row['name_ru'] for row in self.updatedatasetdlg.data_quality_list])
                    selected_quality = self.seismic_datasets_view_list[self.updatedatasetdlg.selected_dataset_row]['data_quality']
                if selected_quality:
                    self.updatedatasetdlg.datasetQualityComboBoxInput.setCurrentText(selected_quality)
                else:
                    self.updatedatasetdlg.datasetQualityComboBoxInput.setCurrentText('--Выбрать--')

            def reload_sizegb():
                size = self.seismic_datasets_view_list[self.updatedatasetdlg.selected_dataset_row]['size_gb']
                if size:
                    self.updatedatasetdlg.datasetSizeGbSpinBoxInput.setValue(size)

            def get_drives_from_postgres():
                sql = f"select * from {self.drives_view}"
                filter_str = self.updatedatasetdlg.datasetAllDrivesFilterLineEditInput.text().lower().strip()
                if filter_str:
                    sql += f" where (LOWER(drive_number) like '%{filter_str}%' or LOWER(drive_type) like '%{filter_str}%' " \
                           f"or LOWER(label) like '%{filter_str}%' or LOWER(conf_name) like '%{filter_str}%' " \
                           f"or LOWER(conf_name_short) like '%{filter_str}%' or LOWER(conf_limit) like '%{filter_str}%')"
                sql += ' order by drive_number'
                try:
                    with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                        if pgconn:
                            with pgconn.cursor() as cur:
                                cur.execute(sql)
                                self.updatedatasetdlg.drives_view_list = cur.fetchall()
                                return True
                        else:
                            self.iface.messageBar().pushMessage('Ошибка',
                                                                'Не удалось загрузить данные о физических носителях из базы',
                                                                level=Qgis.Critical, duration=5)
                            return False
                except:
                    self.iface.messageBar().pushMessage('Ошибка',
                                                        'Не удалось загрузить данные о физических носителях из базы ' + sql,
                                                        level=Qgis.Critical, duration=5)
                    return False
            
            def get_linked_drives_from_postgres():
                selected_dataset_id = self.seismic_datasets_view_list[self.updatedatasetdlg.selected_dataset_row]['dataset_id']
                sql = f"select drive_id from {self.drives_to_datasets} where dataset_id = {str(selected_dataset_id)}"
                try:
                    with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                        if pgconn:
                            with pgconn.cursor() as cur:
                                cur.execute(sql)
                                selected_drive_ids = [x['drive_id'] for x in cur.fetchall()]
                                for drive in self.updatedatasetdlg.drives_view_list:
                                    if drive['drive_id'] in selected_drive_ids and drive not in self.updatedatasetdlg.drives_to_link:
                                        self.updatedatasetdlg.drives_to_link.append(drive)
                                return True
                        else:
                            self.iface.messageBar().pushMessage('Ошибка', 'Не удалось загрузить данные о физических носителях из базы ' + sql, level=Qgis.Critical, duration=5)
                            return False
                except:
                    self.iface.messageBar().pushMessage('Ошибка', 'Не удалось загрузить данные о физических носителях из базы ' + sql, level=Qgis.Critical, duration=5)
                    return False

            def reload_linked_drives():
                self.updatedatasetdlg.datasetLinkedDrivesTableWidget.clear()
                self.updatedatasetdlg.datasetLinkedDrivesTableWidget.setRowCount(0)
                self.updatedatasetdlg.datasetLinkedDrivesTableWidget.setColumnCount(2)
                self.updatedatasetdlg.datasetLinkedDrivesTableWidget.setHorizontalHeaderLabels(['Номер', 'Тип'])
                header = self.updatedatasetdlg.datasetLinkedDrivesTableWidget.horizontalHeader()
                header.resizeSection(0, 130)
                header.resizeSection(1, 50)
                if self.updatedatasetdlg.drives_to_link:
                    for i, drive_row in enumerate(self.updatedatasetdlg.drives_to_link):
                        self.updatedatasetdlg.datasetLinkedDrivesTableWidget.insertRow(i)
                        citem = QTableWidgetItem(drive_row['drive_number'])
                        # print(drive_row['drive_number'])
                        citem.setToolTip(str(drive_row['drive_number']))
                        citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                        self.updatedatasetdlg.datasetLinkedDrivesTableWidget.setItem(i, 0, citem)
                        citem = QTableWidgetItem(drive_row['drive_type'])
                        citem.setToolTip(str(drive_row['drive_type']))
                        citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                        self.updatedatasetdlg.datasetLinkedDrivesTableWidget.setItem(i, 1, citem)
            
            def reload_drives():
                self.updatedatasetdlg.datasetAllDrivesTableWidget.clear()
                self.updatedatasetdlg.datasetAllDrivesTableWidget.setRowCount(0)
                self.updatedatasetdlg.datasetAllDrivesTableWidget.setColumnCount(2)
                self.updatedatasetdlg.datasetAllDrivesTableWidget.setHorizontalHeaderLabels(['Номер', 'Тип'])
                header = self.updatedatasetdlg.datasetAllDrivesTableWidget.horizontalHeader()
                header.resizeSection(0, 148)
                header.resizeSection(1, 50)
                if get_drives_from_postgres():
                    for i, drive_row in enumerate(self.updatedatasetdlg.drives_view_list):
                        self.updatedatasetdlg.datasetAllDrivesTableWidget.insertRow(i)
                        citem = QTableWidgetItem(drive_row['drive_number'])
                        # print(drive_row['drive_number'])
                        citem.setToolTip(str(drive_row['drive_number']))
                        citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                        self.updatedatasetdlg.datasetAllDrivesTableWidget.setItem(i, 0, citem)
                        citem = QTableWidgetItem(drive_row['drive_type'])
                        citem.setToolTip(str(drive_row['drive_type']))
                        citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                        self.updatedatasetdlg.datasetAllDrivesTableWidget.setItem(i, 1, citem)

            def reload_links():
                filter_string = self.updatedatasetdlg.datasetLinksFilterLineEditInput.text().strip().lower().replace("'", "''").replace('\\', '\\\\')
                self.updatedatasetdlg.datasetLinkComboBoxInput.clear()
                sql = f"select * from {self.links}"
                if filter_string:
                    sql += f" where LOWER(link) like'%{filter_string}%'"
                sql += " order by link"
                with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                    with pgconn.cursor() as cur:
                        cur.execute(sql)
                        self.updatedatasetdlg.links_list = list(cur.fetchall())
                        self.updatedatasetdlg.datasetLinkComboBoxInput.addItem('Выберите ссылку')
                        self.updatedatasetdlg.datasetLinkComboBoxInput.addItems([row['link'] for row in self.updatedatasetdlg.links_list])

            def get_linked_links_from_postgres():
                selected_dataset_id = self.seismic_datasets_view_list[self.updatedatasetdlg.selected_dataset_row]['dataset_id']
                sql = f"select link_id from {self.links_to_datasets} where dataset_id = {str(selected_dataset_id)}"
                try:
                    with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                        if pgconn:
                            with pgconn.cursor() as cur:
                                cur.execute(sql)
                                selected_link_ids = [x['link_id'] for x in cur.fetchall()]
                                for link in self.updatedatasetdlg.links_list:
                                    if link['link_id'] in selected_link_ids and link not in self.updatedatasetdlg.links_to_link:
                                        self.updatedatasetdlg.links_to_link.append(link)
                                return True
                        else:
                            self.iface.messageBar().pushMessage('Ошибка',
                                                                'Не удалось загрузить данные о ссылках из базы ' + sql,
                                                                level=Qgis.Critical, duration=5)
                            return False
                except:
                    self.iface.messageBar().pushMessage('Ошибка',
                                                        'Не удалось загрузить данные о ссылках из базы ' + sql,
                                                        level=Qgis.Critical, duration=5)
                    return False
            
            def reload_linked_links():
                self.updatedatasetdlg.datasetLinksTableWidget.clear()
                self.updatedatasetdlg.datasetLinksTableWidget.setRowCount(0)
                self.updatedatasetdlg.datasetLinksTableWidget.setColumnCount(2)
                self.updatedatasetdlg.datasetLinksTableWidget.setHorizontalHeaderLabels(['Адрес', 'id'])
                header = self.updatedatasetdlg.datasetLinksTableWidget.horizontalHeader()
                header.resizeSection(0, 1000)
                header.resizeSection(1, 10)
                if self.updatedatasetdlg.links_to_link:
                    for i, link_row in enumerate(self.updatedatasetdlg.links_to_link):
                        self.updatedatasetdlg.datasetLinksTableWidget.insertRow(i)
                        citem = QTableWidgetItem(link_row['link'])
                        citem.setToolTip(str(link_row['link']))
                        citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                        self.updatedatasetdlg.datasetLinksTableWidget.setItem(i, 0, citem)
                        citem = QTableWidgetItem(link_row['link_id'])
                        citem.setToolTip(str(link_row['link_id']))
                        citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                        self.updatedatasetdlg.datasetLinksTableWidget.setItem(i, 1, citem)

            def reload_transmittals():
                filter_string = self.updatedatasetdlg.datasetTransmittalsFilterLineEditInput.text().strip().lower().replace("'", "''")
                self.updatedatasetdlg.datasetTransmittalComboBoxInput.clear()
                sql = f"select * from {self.transmittals_view}"
                if filter_string:
                    sql += f" where LOWER(transmittal_type) like'%{filter_string}%'" \
                           f" or LOWER(number) like'%{filter_string}%'" \
                           f" or LOWER(name) like'%{filter_string}%'" \
                           f" or LOWER(from_company) like'%{filter_string}%'" \
                           f" or LOWER(to_company) like'%{filter_string}%'" \
                           f" or datestamp::text like'%{filter_string}%'" \
                           f" or LOWER(comments) like'%{filter_string}%'" \
                           f" or LOWER(from_company_short) like'%{filter_string}%'" \
                           f" or LOWER(to_company_short) like'%{filter_string}%'"
                sql += ' order by number'
                with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                    with pgconn.cursor() as cur:
                        cur.execute(sql)
                        self.updatedatasetdlg.transmittals_list = list(cur.fetchall())
                        self.updatedatasetdlg.datasetTransmittalComboBoxInput.addItem('Выберите акт приема-передачи')
                        for row in self.updatedatasetdlg.transmittals_list:
                            transm_item_str = ''
                            if row['number']:
                                transm_item_str += f"{row['number']} "
                            if row['datestamp']:
                                transm_item_str += f"от {row['datestamp']} "
                            if row['from_company_short']:
                                transm_item_str += f" {row['from_company_short']}"
                            if row['to_company_short']:
                                transm_item_str += f"->{row['to_company_short']}"
                            self.updatedatasetdlg.datasetTransmittalComboBoxInput.addItem(transm_item_str)

            def get_linked_transmittals_from_postgres():
                selected_dataset_id = self.seismic_datasets_view_list[self.updatedatasetdlg.selected_dataset_row]['dataset_id']
                sql = f"select transmittal_id from {self.seismic_datasets_to_transmittals} where seismic_dataset_id = {str(selected_dataset_id)}"
                try:
                    with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                        if pgconn:
                            with pgconn.cursor() as cur:
                                cur.execute(sql)
                                selected_transmittal_ids = [x['transmittal_id'] for x in cur.fetchall()]
                                for transm in self.updatedatasetdlg.transmittals_list:
                                    if transm['transmittal_id'] in selected_transmittal_ids and transm not in self.updatedatasetdlg.transmittals_to_link:
                                        self.updatedatasetdlg.transmittals_to_link.append(transm)
                                return True
                        else:
                            self.iface.messageBar().pushMessage('Ошибка',
                                                                'Не удалось загрузить данные об актах из базы ' + sql,
                                                                level=Qgis.Critical, duration=5)
                            return False
                except:
                    self.iface.messageBar().pushMessage('Ошибка',
                                                        'Не удалось загрузить данные об актах из базы ' + sql,
                                                        level=Qgis.Critical, duration=5)
                    return False

            def reload_linked_transmittals():
                self.updatedatasetdlg.datasetTransmittalsTableWidget.clear()
                self.updatedatasetdlg.datasetTransmittalsTableWidget.setRowCount(0)
                self.updatedatasetdlg.datasetTransmittalsTableWidget.setColumnCount(4)
                self.updatedatasetdlg.datasetTransmittalsTableWidget.setHorizontalHeaderLabels(
                    ['Номер', 'Дата', 'Отправитель', 'Получатель'])
                header = self.updatedatasetdlg.datasetTransmittalsTableWidget.horizontalHeader()
                header.resizeSection(0, 70)
                header.resizeSection(1, 70)
                header.resizeSection(2, 100)
                header.resizeSection(3, 100)
                if self.updatedatasetdlg.transmittals_to_link:
                    for i, transmittal_row in enumerate(self.updatedatasetdlg.transmittals_to_link):
                        self.updatedatasetdlg.datasetTransmittalsTableWidget.insertRow(i)
                        citem = QTableWidgetItem(transmittal_row['number'])
                        citem.setToolTip(str(transmittal_row['number']))
                        citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                        self.updatedatasetdlg.datasetTransmittalsTableWidget.setItem(i, 0, citem)
                        citem = QTableWidgetItem(str(transmittal_row['datestamp']))
                        citem.setToolTip(str(transmittal_row['datestamp']))
                        citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                        self.updatedatasetdlg.datasetTransmittalsTableWidget.setItem(i, 1, citem)
                        citem = QTableWidgetItem(str(transmittal_row['from_company_short']))
                        citem.setToolTip(str(transmittal_row['from_company']))
                        citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                        self.updatedatasetdlg.datasetTransmittalsTableWidget.setItem(i, 2, citem)
                        citem = QTableWidgetItem(str(transmittal_row['to_company_short']))
                        citem.setToolTip(str(transmittal_row['to_company']))
                        citem.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                        self.updatedatasetdlg.datasetTransmittalsTableWidget.setItem(i, 3, citem)

            def link_drive():
                selected_drive_rows = list(set([x.row() for x in self.updatedatasetdlg.datasetAllDrivesTableWidget.selectedItems()]))
                if selected_drive_rows:
                    self.updatedatasetdlg.drives_to_link.extend(
                        [self.updatedatasetdlg.drives_view_list[x] for x in selected_drive_rows if
                         self.updatedatasetdlg.drives_view_list[x] not in self.updatedatasetdlg.drives_to_link])
                    reload_linked_drives()
                else:
                    self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать хотя бы один носитель',
                                                        level=Qgis.Warning, duration=5)

            def unlink_drive():
                selected_drive_rows = list(set([x.row() for x in self.updatedatasetdlg.datasetLinkedDrivesTableWidget.selectedItems()]))
                if selected_drive_rows:
                    # [self.updatedatasetdlg.drives_to_link.pop(x) for x in selected_drive_rows]
                    self.updatedatasetdlg.drives_to_link = [x for x in self.updatedatasetdlg.drives_to_link if self.updatedatasetdlg.drives_to_link.index(x) not in selected_drive_rows]
                    reload_linked_drives()
                else:
                    self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать хотя бы один связанный носитель',
                                                        level=Qgis.Warning,
                                                        duration=5)

            def link_link():
                selected_link_index = self.updatedatasetdlg.datasetLinkComboBoxInput.currentIndex() - 1
                if selected_link_index >= 0:
                    if self.updatedatasetdlg.links_list[selected_link_index] not in self.updatedatasetdlg.links_to_link:
                        self.updatedatasetdlg.links_to_link.append(self.updatedatasetdlg.links_list[selected_link_index])
                    reload_linked_links()
                    self.updatedatasetdlg.datasetLinkComboBoxInput.setCurrentIndex(0)

            def unlink_link():
                selected_link_rows = list(set([x.row() for x in self.updatedatasetdlg.datasetLinksTableWidget.selectedItems()]))
                if selected_link_rows:
                    self.updatedatasetdlg.links_to_link = [x for x in self.updatedatasetdlg.links_to_link if self.updatedatasetdlg.links_to_link.index(x) not in selected_link_rows]
                    reload_linked_links()
                else:
                    self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать хотя бы одну связанную ссылку',
                                                        level=Qgis.Warning,
                                                        duration=5)

            def link_transmittal():
                selected_transmittal_index = self.updatedatasetdlg.datasetTransmittalComboBoxInput.currentIndex() - 1
                if selected_transmittal_index >= 0:
                    if self.updatedatasetdlg.transmittals_list[selected_transmittal_index] not in self.updatedatasetdlg.transmittals_to_link:
                        self.updatedatasetdlg.transmittals_to_link.append(self.updatedatasetdlg.transmittals_list[selected_transmittal_index])
                    reload_linked_transmittals()
                    self.updatedatasetdlg.datasetTransmittalComboBoxInput.setCurrentIndex(0)

            def unlink_transmittal():
                selected_transmittal_rows = list(set([x.row() for x in self.updatedatasetdlg.datasetTransmittalsTableWidget.selectedItems()]))
                if selected_transmittal_rows:
                    self.updatedatasetdlg.transmittals_to_link = [x for x in self.updatedatasetdlg.transmittals_to_link if self.updatedatasetdlg.transmittals_to_link.index(x) not in selected_transmittal_rows]
                    reload_linked_transmittals()
                else:
                    self.iface.messageBar().pushMessage('Ошибка',
                                                        'Нужно выбрать хотя бы один связанный акт приема-передачи',
                                                        level=Qgis.Warning,
                                                        duration=5)
            
            def generate_and_execute_sql():
                drive_ids_to_insert = None
                link_ids_to_insert = None
                transmittal_ids_to_insert = None
                selected_dataset_id = self.seismic_datasets_view_list[self.updatedatasetdlg.selected_dataset_row]['dataset_id']
                selected_datasource_type_index = self.updatedatasetdlg.datasetDataSourceTypeComboBoxInput.currentIndex()
                new_shortname = self.updatedatasetdlg.datasetShortnameLineEditInput.text().strip().replace("'", "''")
                new_name = self.updatedatasetdlg.datasetNameLineEditInput.text().strip().replace("'", "''")
                selected_type_index = self.updatedatasetdlg.datasetTypeComboBoxInput.currentIndex()
                selected_format_index = self.updatedatasetdlg.datasetFormatComboBoxInput.currentIndex()
                selected_quality_index = self.updatedatasetdlg.datasetQualityComboBoxInput.currentIndex() - 1
                new_sizegb = self.updatedatasetdlg.datasetSizeGbSpinBoxInput.value()
                if all([new_shortname, new_name, selected_features_list]):
                    selected_datasource_type_id = \
                    self.updatedatasetdlg.datasource_types_list[selected_datasource_type_index]['datasource_type_id']
                    selected_type_id = self.updatedatasetdlg.seismic_types_list[selected_type_index]['seismic_type_id']
                    selected_format_id = self.updatedatasetdlg.formats_list[selected_format_index]['format_id']
                    selected_quality_id = None
                    if selected_quality_index >= 0:
                        selected_quality_id = self.updatedatasetdlg.data_quality_list[selected_quality_index][
                        'data_quality_id']
                    if self.updatedatasetdlg.drives_to_link:
                        drive_ids_to_insert = [x['drive_id'] for x in self.updatedatasetdlg.drives_to_link]
                    if self.updatedatasetdlg.links_to_link:
                        link_ids_to_insert = [x['link_id'] for x in self.updatedatasetdlg.links_to_link]
                    if self.updatedatasetdlg.transmittals_to_link:
                        transmittal_ids_to_insert = [x['transmittal_id'] for x in
                                                     self.updatedatasetdlg.transmittals_to_link]
                    if any(['proc_id' in [f.name() for f in geom_layer.fields()], 'survey_id' in [f.name() for f in geom_layer.fields()]]):
                        geom_field = ''
                        if pol_id_fname in [f.name() for f in geom_layer.fields()]:
                            geom_field = pol_id_fname
                        elif line_id_fname in [f.name() for f in geom_layer.fields()]:
                            geom_field = line_id_fname
                        geom_ids_to_link = [f.attribute(geom_field) for f in selected_features_list]
                    else:
                        geom_ids_to_link = None

                    fields_to_update = ['datasource_type_id', 'shortname', 'name', 'seismic_type_id',
                                        'format_id']
                    values_to_insert = [str(selected_datasource_type_id),
                                        f"'{new_shortname}'", f"'{new_name}'", str(selected_type_id),
                                        str(selected_format_id)]
                    if selected_quality_id:
                        fields_to_update.append('data_quality_id')
                        values_to_insert.append(str(selected_quality_id))
                    if new_sizegb > 0:
                        fields_to_update.append('size_gb')
                        values_to_insert.append(str(new_sizegb))
                    sql = f"update {self.seismic_datasets} set {', '.join([x[0] + ' = ' + x[1] for x in zip(fields_to_update, values_to_insert)])} where dataset_id = {str(selected_dataset_id)};"
                    if drive_ids_to_insert:
                        sql += f" delete from {self.drives_to_datasets} where dataset_id = {str(selected_dataset_id)};"
                        sql += f" insert into {self.drives_to_datasets}(drive_id, dataset_id) " \
                               f"values{', '.join(['(' + str(x) + ', ' + str(selected_dataset_id) + ')' for x in drive_ids_to_insert])}" \
                               f";"
                    if link_ids_to_insert:
                        sql += f" delete from {self.links_to_datasets} where dataset_id = {str(selected_dataset_id)};"
                        sql += f" insert into {self.links_to_datasets}(link_id, dataset_id) " \
                               f"values{', '.join(['(' + str(x) + ', ' + str(selected_dataset_id) + ')' for x in link_ids_to_insert])}" \
                               f";"
                    if transmittal_ids_to_insert:
                        sql += f" delete from {self.seismic_datasets_to_transmittals} where seismic_dataset_id = {str(selected_dataset_id)};"
                        sql += f" insert into {self.seismic_datasets_to_transmittals}(transmittal_id, seismic_dataset_id) " \
                               f"values{', '.join(['(' + str(x) + ', ' + str(selected_dataset_id) + ')' for x in transmittal_ids_to_insert])}" \
                               f";"
                    self.sql = sql
                    mwidget = self.iface.messageBar().createMessage(f"Изменить набор данных {str(new_name)}?")
                    mbutton = QPushButton(mwidget)
                    mbutton.setText('Подтвердить')
                    mbutton.pressed.connect(self.execute_sql)
                    mwidget.layout().addWidget(mbutton)
                    self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=5)
                    self.updatedatasetdlg.accept()
                else:
                    self.iface.messageBar().pushMessage('Ошибка',
                                                        'Нужно указать все обязательные поля',
                                                        level=Qgis.Warning,
                                                        duration=5)
            reload_datasource_types()
            reload_dataset_shortname()
            reload_dataset_name()
            reload_seismic_types()
            reload_formats()
            reload_data_quality()
            reload_sizegb()
            reload_drives()
            get_linked_drives_from_postgres()
            reload_linked_drives()
            reload_links()
            get_linked_links_from_postgres()
            reload_linked_links()
            reload_transmittals()
            get_linked_transmittals_from_postgres()
            reload_linked_transmittals()
            self.updatedatasetdlg.datasetRefreshDrivesButton.clicked.connect(reload_drives)
            self.updatedatasetdlg.datasetAllDrivesFilterLineEditInput.textEdited.connect(reload_drives)
            self.updatedatasetdlg.datasetNewDriveButton.clicked.connect(self.add_drive)
            self.updatedatasetdlg.datasetLinkDriveButton.clicked.connect(link_drive)
            self.updatedatasetdlg.datasetUnLinkDriveButton.clicked.connect(unlink_drive)
            self.updatedatasetdlg.datasetRefreshLinksButton.clicked.connect(reload_links)
            self.updatedatasetdlg.datasetLinksFilterLineEditInput.textEdited.connect(reload_links)
            self.updatedatasetdlg.datasetLinkComboBoxInput.activated.connect(link_link)
            self.updatedatasetdlg.unlinkSelectedLinksButton.clicked.connect(unlink_link)
            self.updatedatasetdlg.datasetNewLinkButton.clicked.connect(self.add_link)
            self.updatedatasetdlg.datasetRefreshTransmittalsButton.clicked.connect(reload_transmittals)
            self.updatedatasetdlg.datasetTransmittalsFilterLineEditInput.textEdited.connect(reload_transmittals)
            self.updatedatasetdlg.datasetTransmittalComboBoxInput.activated.connect(link_transmittal)
            self.updatedatasetdlg.unlinkSelectedTransmittalsButton.clicked.connect(unlink_transmittal)
            self.updatedatasetdlg.datasetNewTransmittalButton.clicked.connect(self.add_transmittal)
            self.updatedatasetdlg.insertDatasetButton.clicked.connect(generate_and_execute_sql)
            self.updatedatasetdlg.show()
        else:
            self.iface.messageBar().pushMessage('Ошибка', 'Нужно выбрать один набор данных', level=Qgis.Warning, duration=3)


    def delete_dataset(self):
        selected_cells = self.wind.datasetTableWidget.selectedItems()
        selected_rows = list(set([x.row() for x in selected_cells]))
        if selected_rows:
            selected_dataset_ids_list = [self.seismic_datasets_view_list[i]['dataset_id'] for i in selected_rows]
            self.sql = f"delete from {self.seismic_datasets} where dataset_id in ({', '.join([str(x) for x in selected_dataset_ids_list])});" \
                       f" delete from {self.datasets_to_geometries} where dataset_id in ({', '.join([str(x) for x in selected_dataset_ids_list])});" \
                       f" delete from {self.drives_to_datasets} where dataset_id in ({', '.join([str(x) for x in selected_dataset_ids_list])});" \
                       f" delete from {self.links_to_datasets} where dataset_id in ({', '.join([str(x) for x in selected_dataset_ids_list])});" \
                       f" delete from {self.seismic_datasets_to_transmittals} where seismic_dataset_id in ({', '.join([str(x) for x in selected_dataset_ids_list])});"
            mwidget = self.iface.messageBar().createMessage(f"Удалить из базы наборы данных {', '.join(['[' + x['shortname'] + ']' for x in [self.seismic_datasets_view_list[i] for i in selected_rows]])}? "
                                                            f"Это приведет к удалению их связей со всеми профилями, площадками, носителями, актами и другими связанными объектами.")
            mbutton = QPushButton(mwidget)
            mbutton.setText('Подтвердить')
            mbutton.pressed.connect(self.execute_sql)
            # mbutton.pressed.connect(self.refresh_datasets)
            mwidget.layout().addWidget(mbutton)
            self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=5)


    def add_drive(self):
        self.adddrivedlg = AddDriveDialog()
        self.adddrivedlg.drive_types_list = None
        self.adddrivedlg.conf_list = None

        def reload_drive_types():
            self.adddrivedlg.driveTypeComboBox.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.drive_types}"
                    cur.execute(sql)
                    self.adddrivedlg.drive_types_list = list(cur.fetchall())
                    self.adddrivedlg.driveTypeComboBox.addItems([row['name'] for row in self.adddrivedlg.drive_types_list])

        def reload_conf():
            self.adddrivedlg.driveConfComboBox.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.conf}"
                    cur.execute(sql)
                    self.adddrivedlg.conf_list = list(cur.fetchall())
                    self.adddrivedlg.driveConfComboBox.addItem('Выберите тип конфиденциальности')
                    self.adddrivedlg.driveConfComboBox.addItems([row['conf_name'] for row in self.adddrivedlg.conf_list])

        reload_drive_types()
        reload_conf()

        def generate_and_execute_sql():
            new_drive_number = self.adddrivedlg.driveNumberLineEdit.text().strip().replace("'", "''")
            if new_drive_number:
                selected_drive_type_index = self.adddrivedlg.driveTypeComboBox.currentIndex()
                selected_drive_type_id = self.adddrivedlg.drive_types_list[selected_drive_type_index]['drive_type_id']
                selected_drive_type_name = self.adddrivedlg.drive_types_list[selected_drive_type_index]['name']
                new_drive_label = self.adddrivedlg.driveLabelTextEdit.toPlainText().strip().replace("'", "''")
                new_drive_sizegb = self.adddrivedlg.driveSizeGbSpinBox.value()
                selected_conf_index = self.adddrivedlg.driveConfComboBox.currentIndex() - 1
                new_drive_conf_limit = self.adddrivedlg.driveConfLimitLineEdit.text().strip().replace("'", "''")
                fields_to_update = 'drive_number, type_id'
                values_to_insert = f"'{new_drive_number}', {str(selected_drive_type_id)}"
                if new_drive_label:
                    fields_to_update += ', label'
                    values_to_insert += f", '{new_drive_label}'"
                if new_drive_sizegb > 0:
                    fields_to_update += ', volume_gb'
                    values_to_insert += f", {str(new_drive_sizegb)}"
                if selected_conf_index >= 0:
                    fields_to_update += ', conf_id'
                    selected_conf_id = self.adddrivedlg.conf_list[selected_conf_index]['conf_id']
                    values_to_insert += f", {str(selected_conf_id)}"
                if new_drive_conf_limit:
                    fields_to_update += ', conf_limit'
                    values_to_insert += f", '{new_drive_conf_limit}'"
                self.sql = f"insert into {self.drives}({fields_to_update}) values({values_to_insert})"
                mwidget = self.iface.messageBar().createMessage(f"Добавить в базу {selected_drive_type_name} {str(new_drive_number)}?")
                mbutton = QPushButton(mwidget)
                mbutton.setText('Подтвердить')
                mbutton.pressed.connect(self.execute_sql)
                mwidget.layout().addWidget(mbutton)
                self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=5)
                self.adddrivedlg.accept()
            else:
                self.iface.messageBar().pushMessage('Ошибка', 'Введите номер и тип нового физ.носителя',
                                                    level=Qgis.Warning, duration=5)
        self.adddrivedlg.insertDriveButton.clicked.connect(generate_and_execute_sql)
        self.adddrivedlg.show()

    def add_link(self):
        self.addlinkdlg = AddLinkDialog()
        def generate_and_execute_sql():
            new_link = self.addlinkdlg.linkPlainTextEdit.toPlainText().strip().replace("'", "''") #.replace('\\', '\\\\')
            if new_link:
                sql = f"select * from {self.links}"
                with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                    with pgconn.cursor() as cur:
                        cur.execute(sql)
                        all_links_list = list(cur.fetchall())
                        if new_link not in [x['link'] for x in all_links_list]:
                            self.sql = f"insert into {self.links}(link) values('{new_link}');"
                            mwidget = self.iface.messageBar().createMessage(
                                f"Добавить в базу новую ссылку {new_link}?")
                            mbutton = QPushButton(mwidget)
                            mbutton.setText('Подтвердить')
                            mbutton.pressed.connect(self.execute_sql)
                            mwidget.layout().addWidget(mbutton)
                            self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=5)
                            self.addlinkdlg.accept()
                        else:
                            self.iface.messageBar().pushMessage('Ошибка', 'Такая ссылка уже есть в базе',
                                                                level=Qgis.Warning, duration=5)
        self.addlinkdlg.insertLinkButton.clicked.connect(generate_and_execute_sql)
        self.addlinkdlg.show()


    def add_transmittal(self):
        self.addtransmittaldlg = AddTransmittalDialog()
        self.addtransmittaldlg.transmittalRefreshCompaniesPushButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.addtransmittaldlg.transmittal_types_list = None
        self.addtransmittaldlg.from_companies_list = None
        self.addtransmittaldlg.to_companies_list = None

        def reload_transmittal_types():
            self.addtransmittaldlg.transmittalTypeComboBox.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.transmittal_types}"
                    cur.execute(sql)
                    self.addtransmittaldlg.transmittal_types_list = cur.fetchall()
                    self.addtransmittaldlg.transmittalTypeComboBox.addItems(
                        [row['name'] for row in self.addtransmittaldlg.transmittal_types_list])

        def reload_from_companies():
            self.addtransmittaldlg.transmittalFromCompanyComboBox.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.companies}"
                    filter_str = self.addtransmittaldlg.transmittalFromCompanyFilterLineEdit.text().lower().strip().replace("'", "''")
                    if filter_str:
                        sql += f" where LOWER(name) like '%{filter_str}%' " \
                               f"or LOWER(shortname) like '%{filter_str}%'"
                    sql += ' order by name'
                    cur.execute(sql)
                    self.addtransmittaldlg.from_companies_list = cur.fetchall()
                    self.addtransmittaldlg.transmittalFromCompanyComboBox.addItem('Выберите отправителя')
                    self.addtransmittaldlg.transmittalFromCompanyComboBox.addItems(
                        [row['name'] for row in self.addtransmittaldlg.from_companies_list])

        def reload_to_companies():
            self.addtransmittaldlg.transmittalToCompanyComboBox.clear()
            with psycopg2.connect(self.dsn, cursor_factory=DictCursor) as pgconn:
                with pgconn.cursor() as cur:
                    sql = f"select * from {self.companies}"
                    filter_str = self.addtransmittaldlg.transmittalToCompanyFilterLineEdit.text().lower().strip().replace("'", "''")
                    if filter_str:
                        sql += f" where LOWER(name) like '%{filter_str}%' " \
                               f"or LOWER(shortname) like '%{filter_str}%'"
                    sql += ' order by name'
                    cur.execute(sql)
                    self.addtransmittaldlg.to_companies_list = cur.fetchall()
                    self.addtransmittaldlg.transmittalToCompanyComboBox.addItem('Выберите отправителя')
                    self.addtransmittaldlg.transmittalToCompanyComboBox.addItems(
                        [row['name'] for row in self.addtransmittaldlg.to_companies_list])

        reload_transmittal_types()
        reload_from_companies()
        reload_to_companies()

        def generate_and_execute_sql():
            selected_transmittal_type_index = self.addtransmittaldlg.transmittalTypeComboBox.currentIndex()
            new_transmittal_number = self.addtransmittaldlg.transmittalNumberLineEdit.text().strip().replace("'", "''")
            # new_transmittal_date = self.addtransmittaldlg.transmittalDateEdit.dateTime()
            new_transmittal_date = self.addtransmittaldlg.transmittalCalendarWidget.selectedDate()
            # selected_contract_date.toString('yyyy-MM-dd')
            selected_transmittal_from_company_index = self.addtransmittaldlg.transmittalFromCompanyComboBox.currentIndex() - 1
            selected_transmittal_to_company_index = self.addtransmittaldlg.transmittalToCompanyComboBox.currentIndex() - 1
            if all([new_transmittal_number,
                    selected_transmittal_from_company_index >= 0,
                    selected_transmittal_to_company_index >= 0]):
                selected_transmittal_type_id = self.addtransmittaldlg.transmittal_types_list[selected_transmittal_type_index]['transmittal_type_id']
                selected_transmittal_from_company_id = self.addtransmittaldlg.from_companies_list[selected_transmittal_from_company_index]['company_id']
                selected_transmittal_to_company_id = self.addtransmittaldlg.to_companies_list[selected_transmittal_to_company_index]['company_id']
                new_transmittal_name = self.addtransmittaldlg.transmittalNameLineEdit.text().strip().lower().replace("'", "''")
                new_transmittal_desc = self.addtransmittaldlg.transmittalDescPlainTextEdit.toPlainText().strip().lower().replace("'", "''")
                new_transmittal_comments = self.addtransmittaldlg.transmittalCommentsPlainTextEdit.toPlainText().strip().lower().replace("'", "''")
                new_transmittal_scan_link = self.addtransmittaldlg.transmittalScanLinkLineEdit.text().strip().lower().replace("'", "''")
                fields_to_update = 'transmittal_type_id, number, datestamp, from_company_id, to_company_id'
                values_to_insert = f"{str(selected_transmittal_type_id)}, " \
                                   f"'{new_transmittal_number}', " \
                                   f"'{new_transmittal_date.toString('yyyy-MM-dd')}', " \
                                   f"{str(selected_transmittal_from_company_id)}, " \
                                   f"{str(selected_transmittal_to_company_id)}"
                if new_transmittal_name:
                    fields_to_update += ', name'
                    values_to_insert += f", '{new_transmittal_name}'"
                if new_transmittal_desc:
                    fields_to_update += ', description'
                    values_to_insert += f", '{new_transmittal_desc}'"
                if new_transmittal_comments:
                    fields_to_update += ', comments'
                    values_to_insert += f", '{new_transmittal_comments}'"
                if new_transmittal_scan_link:
                    fields_to_update += ', scan_link'
                    values_to_insert += f", '{new_transmittal_scan_link}'"
                self.sql = f"insert into {self.transmittals}({fields_to_update}) values({values_to_insert});"
                mwidget = self.iface.messageBar().createMessage(f"Добавить в базу акт {str(new_transmittal_number)}?")
                mbutton = QPushButton(mwidget)
                mbutton.setText('Подтвердить')
                mbutton.pressed.connect(self.execute_sql)
                mwidget.layout().addWidget(mbutton)
                self.iface.messageBar().pushWidget(mwidget, Qgis.Warning, duration=5)
                self.addtransmittaldlg.accept()
            else:
                self.iface.messageBar().pushMessage('Ошибка', 'Нужно указать Тип, Номер, Дату, Отправителя и Получателя акта', level=Qgis.Warning,
                                                    duration=3)
        self.addtransmittaldlg.transmittalFromCompanyFilterLineEdit.textEdited.connect(reload_from_companies)
        self.addtransmittaldlg.transmittalToCompanyFilterLineEdit.textEdited.connect(reload_to_companies)
        self.addtransmittaldlg.transmittalNewCompanyPushButton.clicked.connect(self.add_company)
        self.addtransmittaldlg.transmittalRefreshCompaniesPushButton.clicked.connect(reload_from_companies)
        self.addtransmittaldlg.transmittalRefreshCompaniesPushButton.clicked.connect(reload_to_companies)
        self.addtransmittaldlg.insertTransmittalPushButton.clicked.connect(generate_and_execute_sql)
        self.addtransmittaldlg.show()


    def run_mps(self):
        """Run method that performs all the real work"""
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        try:
            self.dockwindfield.close()
        except:
            pass
        if self.first_start == True:
            self.first_start = False
            # self.dlg = GeoDMDialogProc()
            self.dockwind = GeoDMDockWidgetProc()
        else:
            # self.dlg = GeoDMDialogProc()
            self.dockwind = GeoDMDockWidgetProc()

        self.mode = 'proc'
        self.wind = self.dockwind

        self.dockwind.selectProcForSelectedGeometryButton.setIcon(QIcon(':/plugins/geo_dm/spreadsheet.png'))
        self.dockwind.selectGeometryForSelectedProcButton.setIcon(QIcon(':/plugins/geo_dm/geometry.png'))
        self.dockwind.refreshProcButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.dockwind.refreshSurveyButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.dockwind.selectSurveyForSelectedGeometryButton.setIcon(QIcon(':/plugins/geo_dm/spreadsheet.png'))
        self.dockwind.selectGeometryForSelectedSurveyButton.setIcon(QIcon(':/plugins/geo_dm/geometry.png'))
        self.dockwind.refreshDatasetButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.dockwind.selectDatasetForSelectedGeometryButton.setIcon(QIcon(':/plugins/geo_dm/spreadsheet.png'))
        self.dockwind.selectGeometryForSelectedDatasetButton.setIcon(QIcon(':/plugins/geo_dm/geometry.png'))
        ltreenode = QgsProject.instance().layerTreeRoot().children()
        layers = list(filter(lambda x: x.type() == QgsMapLayerType.VectorLayer and x.isSpatial(), QgsLayerTreeUtils().collectMapLayersRecursive(ltreenode)))
        if layers:
            self.set_selected_proc_features_list()
            self.display_selected_geometry_count()
            self.iface.mapCanvas().selectionChanged.connect(self.set_selected_proc_features_list)
            self.iface.layerTreeView().currentLayerChanged.connect(self.set_selected_proc_features_list)

            self.refresh_processings()
            self.dockwind.selectProcForSelectedGeometryButton.clicked.connect(self.select_proc_by_geometry)
            self.dockwind.selectGeometryForSelectedProcButton.clicked.connect(self.select_geometry_by_proc)
            self.dockwind.refreshProcButton.clicked.connect(self.refresh_processings)
            self.dockwind.procFilterLineEdit.textEdited.connect(self.refresh_processings)
            self.dockwind.addProcPushButton.clicked.connect(self.add_proc)
            self.dockwind.changeProcPushButton.clicked.connect(self.update_proc_for_selected_features)
            self.dockwind.unlinkProcFromGeometryButton.clicked.connect(self.clear_proc_for_selected_geometry)
            self.dockwind.updateProcPushButton.clicked.connect(self.update_proc)
            self.dockwind.deleteProcPushButton.clicked.connect(self.delete_proc)

            self.refresh_surveys()
            self.dockwind.refreshSurveyButton.clicked.connect(self.refresh_surveys)
            self.dockwind.surveyFilterLineEdit.textEdited.connect(self.refresh_surveys)
            self.dockwind.selectSurveyForSelectedGeometryButton.clicked.connect(self.select_surveys_by_geometry)
            self.dockwind.selectGeometryForSelectedSurveyButton.clicked.connect(self.select_geometry_by_surveys)
            self.dockwind.linkSurveyToGeometryButton.clicked.connect(self.link_selected_surveys_to_geometry)
            self.dockwind.unlinkSurveyFromGeometryButton.clicked.connect(self.unlink_selected_surveys_from_geometry)
            self.dockwind.addSurveyPushButton.clicked.connect(self.add_survey)
            self.dockwind.updateSurveyPushButton.clicked.connect(self.update_survey)
            self.dockwind.deleteSurveyPushButton.clicked.connect(self.delete_survey)

            self.dockwind.showSelectedProcDatasetsRadioButton.clicked.connect(self.check_show_datasets_for_selected_proc)
            self.dockwind.showAllProcDatasetsRadioButton.clicked.connect(self.check_show_datasets_for_all_proc)
            self.dockwind.procTableWidget.itemSelectionChanged.connect(self.refresh_datasets)
            self.dockwind.datasetFilterLineEdit.textEdited.connect(self.refresh_datasets)
            self.dockwind.refreshDatasetButton.clicked.connect(self.refresh_datasets)
            self.dockwind.selectDatasetForSelectedGeometryButton.clicked.connect(self.select_datasets_by_geometry)
            self.dockwind.selectGeometryForSelectedDatasetButton.clicked.connect(self.select_geometry_by_datasets)
            self.dockwind.linkDatasetToGeometryButton.clicked.connect(self.link_selected_datasets_to_geometry)
            self.dockwind.unlinkDatasetFromGeometryButton.clicked.connect(self.unlink_selected_datasets_from_geometry)
            self.dockwind.addDatasetPushButton.clicked.connect(self.add_dataset)
            self.dockwind.updateDatasetPushButton.clicked.connect(self.update_dataset)
            self.dockwind.deleteDatasetPushButton.clicked.connect(self.delete_dataset)

            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwind)
            self.dockwind.adjustSize()
        else:
            self.iface.messageBar().pushMessage('Ошибка', 'Необходимо добавить в проекте слой с геометрией сейсмики', level=Qgis.Warning, duration=3)


    def run_mfs(self):
        """Run method that performs all the real work"""
        try:
            self.dockwind.close()
        except:
            pass
        if self.first_start == True:
            self.first_start = False
            self.dockwindfield = GeoDMDockWidgetField()
        else:
            self.dockwindfield = GeoDMDockWidgetField()

        self.mode = 'field'
        self.wind = self.dockwindfield

        self.dockwindfield.selectSurveyForSelectedGeometryButton.setIcon(QIcon(':/plugins/geo_dm/spreadsheet.png'))
        self.dockwindfield.selectGeometryForSelectedSurveyButton.setIcon(QIcon(':/plugins/geo_dm/geometry.png'))
        self.dockwindfield.refreshSurveyButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.dockwindfield.refreshDatasetButton.setIcon(QIcon(':/plugins/geo_dm/refresh.png'))
        self.dockwindfield.selectDatasetForSelectedGeometryButton.setIcon(QIcon(':/plugins/geo_dm/spreadsheet.png'))
        self.dockwindfield.selectGeometryForSelectedDatasetButton.setIcon(QIcon(':/plugins/geo_dm/geometry.png'))

        ltreenode = QgsProject.instance().layerTreeRoot().children()
        layers = list(filter(lambda x: x.type() == QgsMapLayerType.VectorLayer and x.isSpatial(),
                             QgsLayerTreeUtils().collectMapLayersRecursive(ltreenode)))
        if layers:
            self.set_selected_field_features_list()
            self.display_selected_field_geometry_count()
            self.iface.mapCanvas().selectionChanged.connect(self.set_selected_field_features_list)
            self.iface.layerTreeView().currentLayerChanged.connect(self.set_selected_field_features_list)

            self.refresh_surveys()
            self.dockwindfield.refreshSurveyButton.clicked.connect(self.refresh_surveys)
            self.dockwindfield.surveyFilterLineEdit.textEdited.connect(self.refresh_surveys)
            self.dockwindfield.selectSurveyForSelectedGeometryButton.clicked.connect(self.select_surveys_by_geometry)
            self.dockwindfield.selectGeometryForSelectedSurveyButton.clicked.connect(self.select_geometry_by_surveys)
            self.dockwindfield.linkSurveyToGeometryButton.clicked.connect(self.link_selected_surveys_to_geometry)
            self.dockwindfield.unlinkSurveyFromGeometryButton.clicked.connect(self.unlink_selected_surveys_from_geometry)
            self.dockwindfield.addSurveyPushButton.clicked.connect(self.add_survey)
            self.dockwindfield.updateSurveyPushButton.clicked.connect(self.update_survey)
            self.dockwindfield.deleteSurveyPushButton.clicked.connect(self.delete_survey)

            self.dockwindfield.showSelectedSurveyDatasetsRadioButton.clicked.connect(self.check_show_datasets_for_selected_surveys)
            self.dockwindfield.showAllSurveyDatasetsRadioButton.clicked.connect(self.check_show_datasets_for_all_surveys)
            self.dockwindfield.surveyTableWidget.itemSelectionChanged.connect(self.refresh_datasets)
            self.dockwindfield.datasetFilterLineEdit.textEdited.connect(self.refresh_datasets)
            self.dockwindfield.refreshDatasetButton.clicked.connect(self.refresh_datasets)
            self.dockwindfield.selectDatasetForSelectedGeometryButton.clicked.connect(self.select_datasets_by_geometry)
            self.dockwindfield.selectGeometryForSelectedDatasetButton.clicked.connect(self.select_geometry_by_datasets)
            self.dockwindfield.linkDatasetToGeometryButton.clicked.connect(self.link_selected_datasets_to_geometry)
            self.dockwindfield.unlinkDatasetFromGeometryButton.clicked.connect(self.unlink_selected_datasets_from_geometry)
            self.dockwindfield.addDatasetPushButton.clicked.connect(self.add_dataset)
            self.dockwindfield.updateDatasetPushButton.clicked.connect(self.update_dataset)
            self.dockwindfield.deleteDatasetPushButton.clicked.connect(self.delete_dataset)

            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwindfield)
            self.dockwindfield.adjustSize()
        else:
            self.iface.messageBar().pushMessage('Ошибка', 'Необходимо добавить в проект слой с геометрией сейсмики',
                                                level=Qgis.Warning, duration=3)
